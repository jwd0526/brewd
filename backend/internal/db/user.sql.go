// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkEmailAvailability = `-- name: CheckEmailAvailability :one
SELECT NOT EXISTS (
    SELECT 1 FROM "user" WHERE email = $1
) as available
`

// ----------------------------------------------------------------------------
// 9. CHECK EMAIL AVAILABILITY
// ----------------------------------------------------------------------------
// Parameters: $1 = email
// Returns: Boolean (true if available, false if taken)
// Usage: Real-time validation during registration
func (q *Queries) CheckEmailAvailability(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkEmailAvailability, email)
	var available bool
	err := row.Scan(&available)
	return available, err
}

const checkUsernameAvailability = `-- name: CheckUsernameAvailability :one
SELECT NOT EXISTS (
    SELECT 1 FROM "user" WHERE username = $1
) as available
`

// ----------------------------------------------------------------------------
// 8. CHECK USERNAME AVAILABILITY
// ----------------------------------------------------------------------------
// Parameters: $1 = username
// Returns: Boolean (true if available, false if taken)
// Usage: Real-time validation during registration
func (q *Queries) CheckUsernameAvailability(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUsernameAvailability, username)
	var available bool
	err := row.Scan(&available)
	return available, err
}

const createUser = `-- name: CreateUser :one


INSERT INTO "user" (id, username, email, password_hash, joined_at)
VALUES ($1, $2, $3, $4, NOW())
RETURNING id, username, email, joined_at, created_at
`

type CreateUserParams struct {
	ID           string `json:"id"`
	Username     string `json:"username"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

type CreateUserRow struct {
	ID        string             `json:"id"`
	Username  string             `json:"username"`
	Email     string             `json:"email"`
	JoinedAt  pgtype.Timestamptz `json:"joined_at"`
	CreatedAt time.Time          `json:"created_at"`
}

// ============================================================================
// USER QUERIES
// ============================================================================
// Operations for user management: registration, profiles, search, and stats
// ----------------------------------------------------------------------------
// 1. CREATE USER (Registration)
// ----------------------------------------------------------------------------
// Parameters: $1 = id (ULID), $2 = username, $3 = email, $4 = password_hash
// Returns: The created user record
// Usage: Called during user registration
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.JoinedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, profile_picture_url
FROM "user"
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	Email             string  `json:"email"`
	PasswordHash      string  `json:"password_hash"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
}

// ----------------------------------------------------------------------------
// 3. GET USER BY EMAIL (Authentication)
// ----------------------------------------------------------------------------
// Parameters: $1 = email
// Returns: User record including password_hash for authentication
// Usage: Login verification (compare hashed passwords)
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.ProfilePictureUrl,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, profile_picture_url, bio, location, joined_at
FROM "user"
WHERE id = $1
`

type GetUserByIDRow struct {
	ID                string             `json:"id"`
	Username          string             `json:"username"`
	Email             string             `json:"email"`
	ProfilePictureUrl *string            `json:"profile_picture_url"`
	Bio               *string            `json:"bio"`
	Location          *string            `json:"location"`
	JoinedAt          pgtype.Timestamptz `json:"joined_at"`
}

// ----------------------------------------------------------------------------
// 2. GET USER BY ID
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id
// Returns: Single user record (excludes password_hash for security)
// Usage: View user profiles, verify authentication
func (q *Queries) GetUserByID(ctx context.Context, id string) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.Location,
		&i.JoinedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, profile_picture_url, bio, location, joined_at
FROM "user"
WHERE username = $1
`

type GetUserByUsernameRow struct {
	ID                string             `json:"id"`
	Username          string             `json:"username"`
	Email             string             `json:"email"`
	ProfilePictureUrl *string            `json:"profile_picture_url"`
	Bio               *string            `json:"bio"`
	Location          *string            `json:"location"`
	JoinedAt          pgtype.Timestamptz `json:"joined_at"`
}

// ----------------------------------------------------------------------------
// 4. GET USER BY USERNAME
// ----------------------------------------------------------------------------
// Parameters: $1 = username
// Returns: Single user record
// Usage: View profiles by username, check username availability
func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.Location,
		&i.JoinedAt,
	)
	return i, err
}

const getUserProfileWithStats = `-- name: GetUserProfileWithStats :one
SELECT
    u.id,
    u.username,
    u.email,
    u.profile_picture_url,
    u.bio,
    u.location,
    u.joined_at,
    COUNT(DISTINCT p.id) as post_count,
    COUNT(DISTINCT f.friend_id) as friend_count,
    COALESCE(AVG(p.rating), 0) as avg_rating
FROM "user" u
LEFT JOIN post p ON u.id = p.owner_id
LEFT JOIN user_friendships f ON u.id = f.user_id AND f.status = 'accepted'
WHERE u.id = $1
GROUP BY u.id
`

type GetUserProfileWithStatsRow struct {
	ID                string             `json:"id"`
	Username          string             `json:"username"`
	Email             string             `json:"email"`
	ProfilePictureUrl *string            `json:"profile_picture_url"`
	Bio               *string            `json:"bio"`
	Location          *string            `json:"location"`
	JoinedAt          pgtype.Timestamptz `json:"joined_at"`
	PostCount         int64              `json:"post_count"`
	FriendCount       int64              `json:"friend_count"`
	AvgRating         interface{}        `json:"avg_rating"`
}

// ----------------------------------------------------------------------------
// 6. GET USER PROFILE WITH STATS
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id
// Returns: User info + post_count, friend_count, avg_rating
// Usage: Display rich user profiles with activity statistics
// Performance: Uses LEFT JOINs and aggregations, leverages multiple indexes
func (q *Queries) GetUserProfileWithStats(ctx context.Context, id string) (GetUserProfileWithStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserProfileWithStats, id)
	var i GetUserProfileWithStatsRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.Location,
		&i.JoinedAt,
		&i.PostCount,
		&i.FriendCount,
		&i.AvgRating,
	)
	return i, err
}

const searchUsersByUsernameBasic = `-- name: SearchUsersByUsernameBasic :many
SELECT id, username, profile_picture_url, bio
FROM "user"
WHERE username ILIKE $1
ORDER BY username
LIMIT 20
`

type SearchUsersByUsernameBasicRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
	Bio               *string `json:"bio"`
}

// ----------------------------------------------------------------------------
// 7. SEARCH USERS BY USERNAME
// ----------------------------------------------------------------------------
// Parameters: $1 = search_term (use '%term%' for contains, 'term%' for starts with)
// Returns: List of matching users (max 20)
// Usage: User search/discovery feature
// Performance: Uses idx_user_username, fast if pattern doesn't start with %
func (q *Queries) SearchUsersByUsernameBasic(ctx context.Context, username string) ([]SearchUsersByUsernameBasicRow, error) {
	rows, err := q.db.Query(ctx, searchUsersByUsernameBasic, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUsersByUsernameBasicRow{}
	for rows.Next() {
		var i SearchUsersByUsernameBasicRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.Bio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePassword = `-- name: UpdatePassword :one
UPDATE "user"
SET
    password_hash = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, email
`

type UpdatePasswordParams struct {
	ID           string `json:"id"`
	PasswordHash string `json:"password_hash"`
}

type UpdatePasswordRow struct {
	ID    string `json:"id"`
	Email string `json:"email"`
}

// ----------------------------------------------------------------------------
// 10. UPDATE PASSWORD
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id, $2 = new_password_hash
// Returns: Success confirmation
// Usage: Password reset/change functionality
func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) (UpdatePasswordRow, error) {
	row := q.db.QueryRow(ctx, updatePassword, arg.ID, arg.PasswordHash)
	var i UpdatePasswordRow
	err := row.Scan(&i.ID, &i.Email)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE "user"
SET
    profile_picture_url = COALESCE($2, profile_picture_url),
    bio = COALESCE($3, bio),
    location = COALESCE($4, location),
    updated_at = NOW()
WHERE id = $1
RETURNING id, username, email, profile_picture_url, bio, location, updated_at
`

type UpdateUserProfileParams struct {
	ID                string  `json:"id"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
	Bio               *string `json:"bio"`
	Location          *string `json:"location"`
}

type UpdateUserProfileRow struct {
	ID                string    `json:"id"`
	Username          string    `json:"username"`
	Email             string    `json:"email"`
	ProfilePictureUrl *string   `json:"profile_picture_url"`
	Bio               *string   `json:"bio"`
	Location          *string   `json:"location"`
	UpdatedAt         time.Time `json:"updated_at"`
}

// ----------------------------------------------------------------------------
// 5. UPDATE USER PROFILE
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id, $2 = profile_picture_url, $3 = bio, $4 = location
// Returns: Updated user record
// Usage: User edits their profile
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (UpdateUserProfileRow, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.ID,
		arg.ProfilePictureUrl,
		arg.Bio,
		arg.Location,
	)
	var i UpdateUserProfileRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.Location,
		&i.UpdatedAt,
	)
	return i, err
}
