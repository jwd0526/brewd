// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: friendship.sql

package db

import (
	"context"
	"time"
)

const acceptFriendRequestInsert = `-- name: AcceptFriendRequestInsert :one
INSERT INTO user_friendships (user_id, friend_id, status)
VALUES ($2, $1, 'accepted')
RETURNING user_id, friend_id, status, created_at
`

type AcceptFriendRequestInsertParams struct {
	FriendID string `json:"friend_id"`
	UserID   string `json:"user_id"`
}

type AcceptFriendRequestInsertRow struct {
	UserID    string    `json:"user_id"`
	FriendID  string    `json:"friend_id"`
	Status    *string   `json:"status"`
	CreatedAt time.Time `json:"created_at"`
}

// Second query: Create reverse direction
func (q *Queries) AcceptFriendRequestInsert(ctx context.Context, arg AcceptFriendRequestInsertParams) (AcceptFriendRequestInsertRow, error) {
	row := q.db.QueryRow(ctx, acceptFriendRequestInsert, arg.FriendID, arg.UserID)
	var i AcceptFriendRequestInsertRow
	err := row.Scan(
		&i.UserID,
		&i.FriendID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const acceptFriendRequestUpdate = `-- name: AcceptFriendRequestUpdate :one

UPDATE user_friendships
SET status = 'accepted', updated_at = NOW()
WHERE user_id = $1 AND friend_id = $2 AND status = 'pending'
RETURNING user_id, friend_id, status, updated_at
`

type AcceptFriendRequestUpdateParams struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

type AcceptFriendRequestUpdateRow struct {
	UserID    string    `json:"user_id"`
	FriendID  string    `json:"friend_id"`
	Status    *string   `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
}

// ----------------------------------------------------------------------------
// 2. ACCEPT FRIEND REQUEST (Use Transaction!)
// ----------------------------------------------------------------------------
// Parameters: $1 = requester_user_id, $2 = accepter_user_id
// Returns: Both friendship records
// Usage: User B accepts User A's request, creating bidirectional friendship
//
// ⚠️  CRITICAL: These TWO queries MUST be wrapped in a transaction in your application code!
// ⚠️  If the UPDATE succeeds but INSERT fails, you'll have inconsistent data.
//
// Example application code:
//
//	BEGIN;
//	  [Execute first query]
//	  [Execute second query]
//	COMMIT;
//
// First query: Update the pending request
func (q *Queries) AcceptFriendRequestUpdate(ctx context.Context, arg AcceptFriendRequestUpdateParams) (AcceptFriendRequestUpdateRow, error) {
	row := q.db.QueryRow(ctx, acceptFriendRequestUpdate, arg.UserID, arg.FriendID)
	var i AcceptFriendRequestUpdateRow
	err := row.Scan(
		&i.UserID,
		&i.FriendID,
		&i.Status,
		&i.UpdatedAt,
	)
	return i, err
}

const areUsersFriends = `-- name: AreUsersFriends :one
SELECT EXISTS (
    SELECT 1 FROM user_friendships
    WHERE user_id = $1 AND friend_id = $2 AND status = 'accepted'
) as are_friends
`

type AreUsersFriendsParams struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

// ----------------------------------------------------------------------------
// 9. ARE USERS FRIENDS?
// ----------------------------------------------------------------------------
// Parameters: $1 = user_a_id, $2 = user_b_id
// Returns: Boolean (true if friends, false otherwise)
// Usage: Quick check if two users are friends
func (q *Queries) AreUsersFriends(ctx context.Context, arg AreUsersFriendsParams) (bool, error) {
	row := q.db.QueryRow(ctx, areUsersFriends, arg.UserID, arg.FriendID)
	var are_friends bool
	err := row.Scan(&are_friends)
	return are_friends, err
}

const blockUser = `-- name: BlockUser :one
INSERT INTO user_friendships (user_id, friend_id, status)
VALUES ($1, $2, 'blocked')
ON CONFLICT (user_id, friend_id)
DO UPDATE SET status = 'blocked', updated_at = NOW()
RETURNING user_id, friend_id, status, updated_at
`

type BlockUserParams struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

type BlockUserRow struct {
	UserID    string    `json:"user_id"`
	FriendID  string    `json:"friend_id"`
	Status    *string   `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
}

// ----------------------------------------------------------------------------
// 12. BLOCK USER
// ----------------------------------------------------------------------------
// Parameters: $1 = blocker_user_id, $2 = blocked_user_id
// Returns: Block record
// Usage: User blocks another user
// Note: Blocking is ONE-DIRECTIONAL (see user_friendships.sql for details)
func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) (BlockUserRow, error) {
	row := q.db.QueryRow(ctx, blockUser, arg.UserID, arg.FriendID)
	var i BlockUserRow
	err := row.Scan(
		&i.UserID,
		&i.FriendID,
		&i.Status,
		&i.UpdatedAt,
	)
	return i, err
}

const checkFriendshipStatus = `-- name: CheckFriendshipStatus :one
SELECT status
FROM user_friendships
WHERE user_id = $1 AND friend_id = $2
`

type CheckFriendshipStatusParams struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

// ----------------------------------------------------------------------------
// 8. CHECK FRIENDSHIP STATUS
// ----------------------------------------------------------------------------
// Parameters: $1 = current_user_id, $2 = other_user_id
// Returns: Status ('accepted', 'pending', 'blocked', or NULL if no relationship)
// Usage: Determine relationship between two users
func (q *Queries) CheckFriendshipStatus(ctx context.Context, arg CheckFriendshipStatusParams) (*string, error) {
	row := q.db.QueryRow(ctx, checkFriendshipStatus, arg.UserID, arg.FriendID)
	var status *string
	err := row.Scan(&status)
	return status, err
}

const getBlockedUsers = `-- name: GetBlockedUsers :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    f.created_at as blocked_at
FROM "user" u
JOIN user_friendships f ON u.id = f.friend_id
WHERE f.user_id = $1 AND f.status = 'blocked'
ORDER BY f.created_at DESC
`

type GetBlockedUsersRow struct {
	ID                string    `json:"id"`
	Username          string    `json:"username"`
	ProfilePictureUrl *string   `json:"profile_picture_url"`
	BlockedAt         time.Time `json:"blocked_at"`
}

// ----------------------------------------------------------------------------
// 14. GET BLOCKED USERS
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id (blocker)
// Returns: List of users blocked by current user
// Usage: Display blocked users list
func (q *Queries) GetBlockedUsers(ctx context.Context, userID string) ([]GetBlockedUsersRow, error) {
	rows, err := q.db.Query(ctx, getBlockedUsers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBlockedUsersRow{}
	for rows.Next() {
		var i GetBlockedUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.BlockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendCount = `-- name: GetFriendCount :one
SELECT COUNT(*) as friend_count
FROM user_friendships
WHERE user_id = $1 AND status = 'accepted'
`

// ----------------------------------------------------------------------------
// 11. GET FRIEND COUNT
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id
// Returns: Number of accepted friends
// Usage: Display friend count on profile
func (q *Queries) GetFriendCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, getFriendCount, userID)
	var friend_count int64
	err := row.Scan(&friend_count)
	return friend_count, err
}

const getFriendList = `-- name: GetFriendList :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    u.bio,
    f.created_at as friends_since
FROM "user" u
JOIN user_friendships f ON u.id = f.friend_id
WHERE f.user_id = $1 AND f.status = 'accepted'
ORDER BY u.username
`

type GetFriendListRow struct {
	ID                string    `json:"id"`
	Username          string    `json:"username"`
	ProfilePictureUrl *string   `json:"profile_picture_url"`
	Bio               *string   `json:"bio"`
	FriendsSince      time.Time `json:"friends_since"`
}

// ----------------------------------------------------------------------------
// 4. GET FRIEND LIST
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id
// Returns: All accepted friends with user details
// Usage: Display user's friends list
// Performance: Uses idx_user_friendships_status, bidirectional storage makes query simple
func (q *Queries) GetFriendList(ctx context.Context, userID string) ([]GetFriendListRow, error) {
	rows, err := q.db.Query(ctx, getFriendList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFriendListRow{}
	for rows.Next() {
		var i GetFriendListRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.FriendsSince,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMutualFriends = `-- name: GetMutualFriends :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url
FROM "user" u
WHERE u.id IN (
    SELECT f1.friend_id
    FROM user_friendships f1
    JOIN user_friendships f2 ON f1.friend_id = f2.friend_id
    WHERE f1.user_id = $1 AND f2.user_id = $2
        AND f1.status = 'accepted' AND f2.status = 'accepted'
)
ORDER BY u.username
`

type GetMutualFriendsParams struct {
	UserID   string `json:"user_id"`
	UserID_2 string `json:"user_id_2"`
}

type GetMutualFriendsRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
}

// ----------------------------------------------------------------------------
// 10. GET MUTUAL FRIENDS
// ----------------------------------------------------------------------------
// Parameters: $1 = user_a_id, $2 = user_b_id
// Returns: Users who are friends with both user A and user B
// Usage: Show mutual friends between two users
func (q *Queries) GetMutualFriends(ctx context.Context, arg GetMutualFriendsParams) ([]GetMutualFriendsRow, error) {
	rows, err := q.db.Query(ctx, getMutualFriends, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMutualFriendsRow{}
	for rows.Next() {
		var i GetMutualFriendsRow
		if err := rows.Scan(&i.ID, &i.Username, &i.ProfilePictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRequestsReceived = `-- name: GetPendingRequestsReceived :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    u.bio,
    f.created_at as requested_at
FROM "user" u
JOIN user_friendships f ON u.id = f.user_id
WHERE f.friend_id = $1 AND f.status = 'pending'
ORDER BY f.created_at DESC
`

type GetPendingRequestsReceivedRow struct {
	ID                string    `json:"id"`
	Username          string    `json:"username"`
	ProfilePictureUrl *string   `json:"profile_picture_url"`
	Bio               *string   `json:"bio"`
	RequestedAt       time.Time `json:"requested_at"`
}

// ----------------------------------------------------------------------------
// 5. GET PENDING FRIEND REQUESTS (Incoming)
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id (recipient)
// Returns: Users who have sent friend requests
// Usage: Show incoming friend requests for user to accept/reject
// Performance: Uses idx_user_friendships_friend_id
func (q *Queries) GetPendingRequestsReceived(ctx context.Context, friendID string) ([]GetPendingRequestsReceivedRow, error) {
	rows, err := q.db.Query(ctx, getPendingRequestsReceived, friendID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingRequestsReceivedRow{}
	for rows.Next() {
		var i GetPendingRequestsReceivedRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.RequestedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRequestsSent = `-- name: GetPendingRequestsSent :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    u.bio,
    f.created_at as requested_at
FROM "user" u
JOIN user_friendships f ON u.id = f.friend_id
WHERE f.user_id = $1 AND f.status = 'pending'
ORDER BY f.created_at DESC
`

type GetPendingRequestsSentRow struct {
	ID                string    `json:"id"`
	Username          string    `json:"username"`
	ProfilePictureUrl *string   `json:"profile_picture_url"`
	Bio               *string   `json:"bio"`
	RequestedAt       time.Time `json:"requested_at"`
}

// ----------------------------------------------------------------------------
// 6. GET SENT FRIEND REQUESTS (Outgoing)
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id (requester)
// Returns: Users to whom current user has sent pending requests
// Usage: Show outgoing friend requests (for cancellation)
// Performance: Uses idx_user_friendships_user_id
func (q *Queries) GetPendingRequestsSent(ctx context.Context, userID string) ([]GetPendingRequestsSentRow, error) {
	rows, err := q.db.Query(ctx, getPendingRequestsSent, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingRequestsSentRow{}
	for rows.Next() {
		var i GetPendingRequestsSentRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.RequestedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectFriendRequest = `-- name: RejectFriendRequest :one
DELETE FROM user_friendships
WHERE user_id = $1 AND friend_id = $2 AND status = 'pending'
RETURNING user_id, friend_id
`

type RejectFriendRequestParams struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

type RejectFriendRequestRow struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

// ----------------------------------------------------------------------------
// 3. REJECT/CANCEL FRIEND REQUEST
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id, $2 = friend_id
// Returns: Deleted friendship id
// Usage: Reject incoming request or cancel outgoing request
func (q *Queries) RejectFriendRequest(ctx context.Context, arg RejectFriendRequestParams) (RejectFriendRequestRow, error) {
	row := q.db.QueryRow(ctx, rejectFriendRequest, arg.UserID, arg.FriendID)
	var i RejectFriendRequestRow
	err := row.Scan(&i.UserID, &i.FriendID)
	return i, err
}

const sendFriendRequest = `-- name: SendFriendRequest :one


INSERT INTO user_friendships (user_id, friend_id, status)
VALUES ($1, $2, 'pending')
RETURNING user_id, friend_id, status, created_at
`

type SendFriendRequestParams struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

type SendFriendRequestRow struct {
	UserID    string    `json:"user_id"`
	FriendID  string    `json:"friend_id"`
	Status    *string   `json:"status"`
	CreatedAt time.Time `json:"created_at"`
}

// ============================================================================
// FRIENDSHIP QUERIES
// ============================================================================
// Operations for friendships: send requests, accept, list friends, pending requests
// NOTE: Uses bidirectional storage model - see user_friendships.sql for details
// ----------------------------------------------------------------------------
// 1. SEND FRIEND REQUEST
// ----------------------------------------------------------------------------
// Parameters: $1 = user_id (requester), $2 = friend_id (recipient)
// Returns: The created friendship record
// Usage: User A sends friend request to User B
// Note: Creates single 'pending' row, reverse row created on acceptance
func (q *Queries) SendFriendRequest(ctx context.Context, arg SendFriendRequestParams) (SendFriendRequestRow, error) {
	row := q.db.QueryRow(ctx, sendFriendRequest, arg.UserID, arg.FriendID)
	var i SendFriendRequestRow
	err := row.Scan(
		&i.UserID,
		&i.FriendID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const unblockUser = `-- name: UnblockUser :one
DELETE FROM user_friendships
WHERE user_id = $1 AND friend_id = $2 AND status = 'blocked'
RETURNING user_id, friend_id
`

type UnblockUserParams struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

type UnblockUserRow struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

// ----------------------------------------------------------------------------
// 13. UNBLOCK USER
// ----------------------------------------------------------------------------
// Parameters: $1 = blocker_user_id, $2 = blocked_user_id
// Returns: Deleted block record
// Usage: User unblocks another user
func (q *Queries) UnblockUser(ctx context.Context, arg UnblockUserParams) (UnblockUserRow, error) {
	row := q.db.QueryRow(ctx, unblockUser, arg.UserID, arg.FriendID)
	var i UnblockUserRow
	err := row.Scan(&i.UserID, &i.FriendID)
	return i, err
}

const unfriend = `-- name: Unfriend :exec
DELETE FROM user_friendships
WHERE (user_id = $1 AND friend_id = $2)
   OR (user_id = $2 AND friend_id = $1)
`

type UnfriendParams struct {
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

// ----------------------------------------------------------------------------
// 7. UNFRIEND (Use Transaction!)
// ----------------------------------------------------------------------------
// Parameters: $1 = user_a_id, $2 = user_b_id
// Returns: Number of deleted rows (should be 2)
// Usage: Remove friendship between two users
//
// ⚠️  CRITICAL: This query MUST be wrapped in a transaction in your application code!
// ⚠️  If only one row is deleted due to error, you'll have inconsistent data.
//
// Example application code:
//
//	BEGIN;
//	  [Execute DELETE query]
//	  [Verify 2 rows affected]
//	COMMIT;
func (q *Queries) Unfriend(ctx context.Context, arg UnfriendParams) error {
	_, err := q.db.Exec(ctx, unfriend, arg.UserID, arg.FriendID)
	return err
}
