// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: search.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveUsers = `-- name: GetActiveUsers :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    COUNT(p.id) as post_count,
    AVG(p.rating) as avg_rating
FROM "user" u
JOIN post p ON u.id = p.owner_id
WHERE p.created_at > NOW() - INTERVAL '1 day' * $1
GROUP BY u.id
ORDER BY post_count DESC
LIMIT $2
`

type GetActiveUsersParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetActiveUsersRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
	PostCount         int64   `json:"post_count"`
	AvgRating         float64 `json:"avg_rating"`
}

// 10. GET ACTIVE USERS
// Parameters: $1 = days (time window), $2 = limit
// Returns: Most active users by post count in time period
// Usage: "Active brewers" leaderboard
func (q *Queries) GetActiveUsers(ctx context.Context, arg GetActiveUsersParams) ([]GetActiveUsersRow, error) {
	rows, err := q.db.Query(ctx, getActiveUsers, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveUsersRow{}
	for rows.Next() {
		var i GetActiveUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.PostCount,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularBrews = `-- name: GetPopularBrews :many

SELECT
    b.id,
    b.name,
    b.brew_method,
    b.bean_origin,
    b.roaster,
    COUNT(p.id) as post_count,
    AVG(p.rating) as avg_rating
FROM brew b
JOIN post p ON b.id = p.brew_id
WHERE b.is_public = true
    AND p.created_at > NOW() - INTERVAL '1 day' * $1
    AND p.visibility = 'public'
GROUP BY b.id
HAVING COUNT(p.id) >= 3
ORDER BY post_count DESC, avg_rating DESC
LIMIT $2
`

type GetPopularBrewsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetPopularBrewsRow struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	BrewMethod *string `json:"brew_method"`
	BeanOrigin *string `json:"bean_origin"`
	Roaster    *string `json:"roaster"`
	PostCount  int64   `json:"post_count"`
	AvgRating  float64 `json:"avg_rating"`
}

// ----------------------------------------------------------------------------
// POPULAR/TRENDING CONTENT
// ----------------------------------------------------------------------------
// 7. GET POPULAR BREWS
// Parameters: $1 = days (e.g., 30 for last 30 days), $2 = limit
// Returns: Most-used brews in time period
// Usage: "Trending brews" section
// Performance: Uses idx_post_brew_id and idx_post_created_at
func (q *Queries) GetPopularBrews(ctx context.Context, arg GetPopularBrewsParams) ([]GetPopularBrewsRow, error) {
	rows, err := q.db.Query(ctx, getPopularBrews, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularBrewsRow{}
	for rows.Next() {
		var i GetPopularBrewsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BrewMethod,
			&i.BeanOrigin,
			&i.Roaster,
			&i.PostCount,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularPosts = `-- name: GetPopularPosts :many
SELECT
    p.id,
    p.title,
    p.description,
    p.rating,
    p.created_at,
    u.id as owner_id,
    u.username,
    u.profile_picture_url,
    b.name as brew_name,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count,
    (COUNT(DISTINCT pl.user_id) + COUNT(DISTINCT c.id)) as engagement_score
FROM post p
JOIN "user" u ON p.owner_id = u.id
LEFT JOIN brew b ON p.brew_id = b.id
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
WHERE p.visibility = 'public'
    AND p.created_at > NOW() - INTERVAL '1 day' * $1
GROUP BY p.id, u.id, u.username, u.profile_picture_url, b.name
HAVING (COUNT(DISTINCT pl.user_id) + COUNT(DISTINCT c.id)) > 0
ORDER BY engagement_score DESC, p.created_at DESC
LIMIT $2
`

type GetPopularPostsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetPopularPostsRow struct {
	ID                string         `json:"id"`
	Title             string         `json:"title"`
	Description       *string        `json:"description"`
	Rating            pgtype.Numeric `json:"rating"`
	CreatedAt         time.Time      `json:"created_at"`
	OwnerID           string         `json:"owner_id"`
	Username          string         `json:"username"`
	ProfilePictureUrl *string        `json:"profile_picture_url"`
	BrewName          *string        `json:"brew_name"`
	LikeCount         int64          `json:"like_count"`
	CommentCount      int64          `json:"comment_count"`
	EngagementScore   int32          `json:"engagement_score"`
}

// 8. GET POPULAR POSTS
// Parameters: $1 = days (time window), $2 = limit
// Returns: Posts with most engagement (likes + comments)
// Usage: "Trending posts" feed
// Performance: Aggregates engagement metrics
func (q *Queries) GetPopularPosts(ctx context.Context, arg GetPopularPostsParams) ([]GetPopularPostsRow, error) {
	rows, err := q.db.Query(ctx, getPopularPosts, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularPostsRow{}
	for rows.Next() {
		var i GetPopularPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Rating,
			&i.CreatedAt,
			&i.OwnerID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.BrewName,
			&i.LikeCount,
			&i.CommentCount,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyJoinedUsers = `-- name: GetRecentlyJoinedUsers :many
SELECT
    id,
    username,
    profile_picture_url,
    bio,
    joined_at
FROM "user"
WHERE joined_at > NOW() - INTERVAL '1 day' * $1
ORDER BY joined_at DESC
LIMIT $2
`

type GetRecentlyJoinedUsersParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetRecentlyJoinedUsersRow struct {
	ID                string             `json:"id"`
	Username          string             `json:"username"`
	ProfilePictureUrl *string            `json:"profile_picture_url"`
	Bio               *string            `json:"bio"`
	JoinedAt          pgtype.Timestamptz `json:"joined_at"`
}

// 13. GET RECENTLY JOINED USERS
// Parameters: $1 = days, $2 = limit
// Returns: Users who joined recently
// Usage: "New to the community" section
func (q *Queries) GetRecentlyJoinedUsers(ctx context.Context, arg GetRecentlyJoinedUsersParams) ([]GetRecentlyJoinedUsersRow, error) {
	rows, err := q.db.Query(ctx, getRecentlyJoinedUsers, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentlyJoinedUsersRow{}
	for rows.Next() {
		var i GetRecentlyJoinedUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarBrews = `-- name: GetSimilarBrews :many

SELECT
    b.id,
    b.name,
    b.brew_method,
    b.bean_origin,
    b.roaster,
    COUNT(p.id) as usage_count
FROM brew b
LEFT JOIN post p ON b.id = p.brew_id
WHERE b.is_public = true
    AND b.id != $1
    AND (
        b.brew_method = (SELECT brew_method FROM brew WHERE id = $1)
        OR b.bean_origin = (SELECT bean_origin FROM brew WHERE id = $1)
    )
GROUP BY b.id
ORDER BY usage_count DESC
LIMIT 10
`

type GetSimilarBrewsRow struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	BrewMethod *string `json:"brew_method"`
	BeanOrigin *string `json:"bean_origin"`
	Roaster    *string `json:"roaster"`
	UsageCount int64   `json:"usage_count"`
}

// ----------------------------------------------------------------------------
// RECOMMENDATIONS
// ----------------------------------------------------------------------------
// 11. GET SIMILAR BREWS
// Parameters: $1 = brew_id
// Returns: Brews with similar characteristics (same method or origin)
// Usage: "You might also like" recommendations
func (q *Queries) GetSimilarBrews(ctx context.Context, id string) ([]GetSimilarBrewsRow, error) {
	rows, err := q.db.Query(ctx, getSimilarBrews, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSimilarBrewsRow{}
	for rows.Next() {
		var i GetSimilarBrewsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BrewMethod,
			&i.BeanOrigin,
			&i.Roaster,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuggestedFriends = `-- name: GetSuggestedFriends :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    u.bio,
    COUNT(DISTINCT mf.friend_id) as mutual_friend_count
FROM "user" u
JOIN user_friendships fof ON u.id = fof.user_id
JOIN user_friendships mf ON fof.friend_id = mf.friend_id
WHERE mf.user_id = $1
    AND mf.status = 'accepted'
    AND fof.status = 'accepted'
    AND u.id != $1
    AND NOT EXISTS (
        SELECT 1 FROM user_friendships
        WHERE user_id = $1 AND friend_id = u.id
    )
GROUP BY u.id
ORDER BY mutual_friend_count DESC
LIMIT $2
`

type GetSuggestedFriendsParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
}

type GetSuggestedFriendsRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
	Bio               *string `json:"bio"`
	MutualFriendCount int64   `json:"mutual_friend_count"`
}

// 12. GET SUGGESTED FRIENDS
// Parameters: $1 = current_user_id, $2 = limit
// Returns: Users with mutual friends (friend-of-friend suggestions)
// Usage: "People you may know" recommendations
func (q *Queries) GetSuggestedFriends(ctx context.Context, arg GetSuggestedFriendsParams) ([]GetSuggestedFriendsRow, error) {
	rows, err := q.db.Query(ctx, getSuggestedFriends, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSuggestedFriendsRow{}
	for rows.Next() {
		var i GetSuggestedFriendsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.MutualFriendCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRatedBrews = `-- name: GetTopRatedBrews :many
SELECT
    b.id,
    b.name,
    b.brew_method,
    b.bean_origin,
    b.roaster,
    COUNT(p.id) as post_count,
    AVG(p.rating) as avg_rating,
    MAX(p.rating) as max_rating,
    MIN(p.rating) as min_rating
FROM brew b
JOIN post p ON b.id = p.brew_id
WHERE b.is_public = true AND p.visibility = 'public'
GROUP BY b.id
HAVING COUNT(p.id) >= $1
ORDER BY avg_rating DESC, post_count DESC
LIMIT $2
`

type GetTopRatedBrewsParams struct {
	ID    string `json:"id"`
	Limit int32  `json:"limit"`
}

type GetTopRatedBrewsRow struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	BrewMethod *string     `json:"brew_method"`
	BeanOrigin *string     `json:"bean_origin"`
	Roaster    *string     `json:"roaster"`
	PostCount  int64       `json:"post_count"`
	AvgRating  float64     `json:"avg_rating"`
	MaxRating  interface{} `json:"max_rating"`
	MinRating  interface{} `json:"min_rating"`
}

// 9. GET TOP RATED BREWS
// Parameters: $1 = minimum_post_count, $2 = limit
// Returns: Highest-rated brews with enough posts for statistical validity
// Usage: "Best brews" discovery
func (q *Queries) GetTopRatedBrews(ctx context.Context, arg GetTopRatedBrewsParams) ([]GetTopRatedBrewsRow, error) {
	rows, err := q.db.Query(ctx, getTopRatedBrews, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopRatedBrewsRow{}
	for rows.Next() {
		var i GetTopRatedBrewsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BrewMethod,
			&i.BeanOrigin,
			&i.Roaster,
			&i.PostCount,
			&i.AvgRating,
			&i.MaxRating,
			&i.MinRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBrews = `-- name: SearchBrews :many

SELECT
    b.id,
    b.name,
    b.brew_method,
    b.bean_origin,
    b.roaster,
    b.notes,
    COUNT(p.id) as usage_count
FROM brew b
LEFT JOIN post p ON b.id = p.brew_id
WHERE b.is_public = true
    AND (
        b.name ILIKE $1
        OR b.brew_method ILIKE $1
        OR b.bean_origin ILIKE $1
        OR b.roaster ILIKE $1
    )
GROUP BY b.id
ORDER BY usage_count DESC, b.name
LIMIT 20
`

type SearchBrewsRow struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	BrewMethod *string `json:"brew_method"`
	BeanOrigin *string `json:"bean_origin"`
	Roaster    *string `json:"roaster"`
	Notes      *string `json:"notes"`
	UsageCount int64   `json:"usage_count"`
}

// ----------------------------------------------------------------------------
// BREW SEARCH
// ----------------------------------------------------------------------------
// 3. SEARCH BREWS
// Parameters: $1 = search_term (searches name, brew_method, bean_origin, roaster)
// Returns: Matching brews with usage count
// Usage: Search for coffee brews
// Performance: Uses idx_brew_name and idx_brew_method
func (q *Queries) SearchBrews(ctx context.Context, name string) ([]SearchBrewsRow, error) {
	rows, err := q.db.Query(ctx, searchBrews, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBrewsRow{}
	for rows.Next() {
		var i SearchBrewsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BrewMethod,
			&i.BeanOrigin,
			&i.Roaster,
			&i.Notes,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBrewsByMethod = `-- name: SearchBrewsByMethod :many
SELECT
    b.id,
    b.name,
    b.brew_method,
    b.bean_origin,
    b.roaster,
    COUNT(p.id) as usage_count
FROM brew b
LEFT JOIN post p ON b.id = p.brew_id
WHERE b.is_public = true AND b.brew_method = $1
GROUP BY b.id
ORDER BY usage_count DESC
LIMIT 20
`

type SearchBrewsByMethodRow struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	BrewMethod *string `json:"brew_method"`
	BeanOrigin *string `json:"bean_origin"`
	Roaster    *string `json:"roaster"`
	UsageCount int64   `json:"usage_count"`
}

// 4. SEARCH BREWS BY METHOD
// Parameters: $1 = brew_method (exact match)
// Returns: All brews using this method
// Usage: Filter brews by brewing method
// Performance: Uses idx_brew_method
func (q *Queries) SearchBrewsByMethod(ctx context.Context, brewMethod *string) ([]SearchBrewsByMethodRow, error) {
	rows, err := q.db.Query(ctx, searchBrewsByMethod, brewMethod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBrewsByMethodRow{}
	for rows.Next() {
		var i SearchBrewsByMethodRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BrewMethod,
			&i.BeanOrigin,
			&i.Roaster,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBrewsByRoaster = `-- name: SearchBrewsByRoaster :many
SELECT
    b.id,
    b.name,
    b.brew_method,
    b.bean_origin,
    b.roaster,
    COUNT(p.id) as usage_count
FROM brew b
LEFT JOIN post p ON b.id = p.brew_id
WHERE b.is_public = true AND b.roaster ILIKE $1
GROUP BY b.id
ORDER BY usage_count DESC
LIMIT 20
`

type SearchBrewsByRoasterRow struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	BrewMethod *string `json:"brew_method"`
	BeanOrigin *string `json:"bean_origin"`
	Roaster    *string `json:"roaster"`
	UsageCount int64   `json:"usage_count"`
}

// 5. SEARCH BREWS BY ROASTER
// Parameters: $1 = roaster (case-insensitive)
// Returns: All brews from this roaster
// Usage: Discover brews from a specific roaster
func (q *Queries) SearchBrewsByRoaster(ctx context.Context, roaster *string) ([]SearchBrewsByRoasterRow, error) {
	rows, err := q.db.Query(ctx, searchBrewsByRoaster, roaster)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBrewsByRoasterRow{}
	for rows.Next() {
		var i SearchBrewsByRoasterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BrewMethod,
			&i.BeanOrigin,
			&i.Roaster,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPosts = `-- name: SearchPosts :many

SELECT
    p.id,
    p.title,
    p.description,
    p.rating,
    p.created_at,
    u.id as owner_id,
    u.username,
    u.profile_picture_url,
    b.name as brew_name,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count
FROM post p
JOIN "user" u ON p.owner_id = u.id
LEFT JOIN brew b ON p.brew_id = b.id
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
WHERE p.visibility = 'public'
    AND (p.title ILIKE $1 OR p.description ILIKE $1)
GROUP BY p.id, u.id, u.username, u.profile_picture_url, b.name
ORDER BY p.created_at DESC
LIMIT 20
`

type SearchPostsRow struct {
	ID                string         `json:"id"`
	Title             string         `json:"title"`
	Description       *string        `json:"description"`
	Rating            pgtype.Numeric `json:"rating"`
	CreatedAt         time.Time      `json:"created_at"`
	OwnerID           string         `json:"owner_id"`
	Username          string         `json:"username"`
	ProfilePictureUrl *string        `json:"profile_picture_url"`
	BrewName          *string        `json:"brew_name"`
	LikeCount         int64          `json:"like_count"`
	CommentCount      int64          `json:"comment_count"`
}

// ----------------------------------------------------------------------------
// POST SEARCH
// ----------------------------------------------------------------------------
// 6. SEARCH POSTS
// Parameters: $1 = search_term (searches title and description)
// Returns: Matching posts with owner and engagement metrics
// Usage: Search for specific posts/content
func (q *Queries) SearchPosts(ctx context.Context, title string) ([]SearchPostsRow, error) {
	rows, err := q.db.Query(ctx, searchPosts, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPostsRow{}
	for rows.Next() {
		var i SearchPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Rating,
			&i.CreatedAt,
			&i.OwnerID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.BrewName,
			&i.LikeCount,
			&i.CommentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByUsername = `-- name: SearchUsersByUsername :many



SELECT
    id,
    username,
    profile_picture_url,
    bio,
    location
FROM "user"
WHERE username ILIKE $1
ORDER BY username
LIMIT 20
`

type SearchUsersByUsernameRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
	Bio               *string `json:"bio"`
	Location          *string `json:"location"`
}

// ============================================================================
// SEARCH & DISCOVERY QUERIES
// ============================================================================
// Operations for searching users, brews, posts, and discovering popular content
// ----------------------------------------------------------------------------
// USER SEARCH
// ----------------------------------------------------------------------------
// 1. SEARCH USERS BY USERNAME
// Parameters: $1 = search_term (use '%term%' for contains, 'term%' for starts with)
// Returns: Matching users with basic info
// Usage: User search bar
// Performance: Fast if pattern doesn't start with %, uses idx_user_username
func (q *Queries) SearchUsersByUsername(ctx context.Context, username string) ([]SearchUsersByUsernameRow, error) {
	rows, err := q.db.Query(ctx, searchUsersByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUsersByUsernameRow{}
	for rows.Next() {
		var i SearchUsersByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersWithStats = `-- name: SearchUsersWithStats :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    u.bio,
    COUNT(DISTINCT p.id) as post_count,
    COUNT(DISTINCT f.friend_id) as friend_count
FROM "user" u
LEFT JOIN post p ON u.id = p.owner_id
LEFT JOIN user_friendships f ON u.id = f.user_id AND f.status = 'accepted'
WHERE u.username ILIKE $1
GROUP BY u.id
ORDER BY friend_count DESC, post_count DESC
LIMIT 20
`

type SearchUsersWithStatsRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
	Bio               *string `json:"bio"`
	PostCount         int64   `json:"post_count"`
	FriendCount       int64   `json:"friend_count"`
}

// 2. SEARCH USERS WITH STATS
// Parameters: $1 = search_term
// Returns: Matching users with friend/post counts
// Usage: Enhanced user search with activity indicators
func (q *Queries) SearchUsersWithStats(ctx context.Context, username string) ([]SearchUsersWithStatsRow, error) {
	rows, err := q.db.Query(ctx, searchUsersWithStats, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUsersWithStatsRow{}
	for rows.Next() {
		var i SearchUsersWithStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.PostCount,
			&i.FriendCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
