// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notification.sql

package db

import (
	"context"
	"time"
)

const checkForDuplicateNotification = `-- name: CheckForDuplicateNotification :one
SELECT EXISTS (
    SELECT 1 FROM notification
    WHERE recipient_user_id = $1
        AND actor_user_id = $2
        AND type = $3
        AND reference_id = $4
        AND created_at > NOW() - INTERVAL '1 hour' * $5
) as duplicate_exists
`

type CheckForDuplicateNotificationParams struct {
	RecipientUserID string      `json:"recipient_user_id"`
	ActorUserID     string      `json:"actor_user_id"`
	Type            string      `json:"type"`
	ReferenceID     *string     `json:"reference_id"`
	Column5         interface{} `json:"column_5"`
}

// ----------------------------------------------------------------------------
// 12. CHECK FOR DUPLICATE NOTIFICATION
// ----------------------------------------------------------------------------
// Parameters: $1 = recipient_user_id, $2 = actor_user_id, $3 = type,
//
//	$4 = reference_id, $5 = hours (e.g., 24)
//
// Returns: Boolean (true if duplicate exists)
// Usage: Prevent duplicate notifications within time window
// Example: Don't notify twice if same user likes and unlikes quickly
func (q *Queries) CheckForDuplicateNotification(ctx context.Context, arg CheckForDuplicateNotificationParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkForDuplicateNotification,
		arg.RecipientUserID,
		arg.ActorUserID,
		arg.Type,
		arg.ReferenceID,
		arg.Column5,
	)
	var duplicate_exists bool
	err := row.Scan(&duplicate_exists)
	return duplicate_exists, err
}

const createNotification = `-- name: CreateNotification :one


INSERT INTO notification (id, recipient_user_id, actor_user_id, type, reference_id, reference_type)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, recipient_user_id, actor_user_id, type, reference_id, reference_type, is_read, created_at
`

type CreateNotificationParams struct {
	ID              string  `json:"id"`
	RecipientUserID string  `json:"recipient_user_id"`
	ActorUserID     string  `json:"actor_user_id"`
	Type            string  `json:"type"`
	ReferenceID     *string `json:"reference_id"`
	ReferenceType   *string `json:"reference_type"`
}

// ============================================================================
// NOTIFICATION QUERIES
// ============================================================================
// Operations for user notifications: create, fetch, mark as read
// ----------------------------------------------------------------------------
// 1. CREATE NOTIFICATION
// ----------------------------------------------------------------------------
// Parameters: $1 = id (ULID), $2 = recipient_user_id, $3 = actor_user_id,
//
//	$4 = type, $5 = reference_id, $6 = reference_type
//
// Returns: Created notification record
// Usage: Notify user of actions (like, comment, friend request, tag)
// Types: 'like', 'comment', 'friend_request', 'tag', 'follow'
// Reference types: 'post', 'comment', 'friendship'
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.ID,
		arg.RecipientUserID,
		arg.ActorUserID,
		arg.Type,
		arg.ReferenceID,
		arg.ReferenceType,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.RecipientUserID,
		&i.ActorUserID,
		&i.Type,
		&i.ReferenceID,
		&i.ReferenceType,
		&i.IsRead,
		&i.CreatedAt,
	)
	return i, err
}

const deleteNotification = `-- name: DeleteNotification :one
DELETE FROM notification
WHERE id = $1 AND recipient_user_id = $2
RETURNING id
`

type DeleteNotificationParams struct {
	ID              string `json:"id"`
	RecipientUserID string `json:"recipient_user_id"`
}

// ----------------------------------------------------------------------------
// 7. DELETE NOTIFICATION
// ----------------------------------------------------------------------------
// Parameters: $1 = notification_id, $2 = recipient_user_id
// Returns: Deleted notification id
// Usage: User dismisses a notification
// Note: Includes recipient_user_id check for security
func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) (string, error) {
	row := q.db.QueryRow(ctx, deleteNotification, arg.ID, arg.RecipientUserID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteOldReadNotifications = `-- name: DeleteOldReadNotifications :many
DELETE FROM notification
WHERE recipient_user_id = $1
    AND is_read = true
    AND created_at < NOW() - INTERVAL '1 day' * $2
RETURNING id
`

type DeleteOldReadNotificationsParams struct {
	RecipientUserID string      `json:"recipient_user_id"`
	Column2         interface{} `json:"column_2"`
}

// ----------------------------------------------------------------------------
// 10. DELETE OLD READ NOTIFICATIONS
// ----------------------------------------------------------------------------
// Parameters: $1 = recipient_user_id, $2 = days_old (e.g., 30)
// Returns: Number of deleted notifications
// Usage: Cleanup old notifications (scheduled job)
// Note: Only deletes READ notifications older than X days
func (q *Queries) DeleteOldReadNotifications(ctx context.Context, arg DeleteOldReadNotificationsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, deleteOldReadNotifications, arg.RecipientUserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllNotifications = `-- name: GetAllNotifications :many
SELECT
    n.id,
    n.type,
    n.reference_id,
    n.reference_type,
    n.is_read,
    n.created_at,
    u.id as actor_id,
    u.username as actor_username,
    u.profile_picture_url as actor_profile_picture
FROM notification n
JOIN "user" u ON n.actor_user_id = u.id
WHERE n.recipient_user_id = $1
ORDER BY n.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAllNotificationsParams struct {
	RecipientUserID string `json:"recipient_user_id"`
	Limit           int32  `json:"limit"`
	Offset          int32  `json:"offset"`
}

type GetAllNotificationsRow struct {
	ID                  string    `json:"id"`
	Type                string    `json:"type"`
	ReferenceID         *string   `json:"reference_id"`
	ReferenceType       *string   `json:"reference_type"`
	IsRead              *bool     `json:"is_read"`
	CreatedAt           time.Time `json:"created_at"`
	ActorID             string    `json:"actor_id"`
	ActorUsername       string    `json:"actor_username"`
	ActorProfilePicture *string   `json:"actor_profile_picture"`
}

// ----------------------------------------------------------------------------
// 3. GET ALL NOTIFICATIONS (Read and Unread)
// ----------------------------------------------------------------------------
// Parameters: $1 = recipient_user_id, $2 = limit, $3 = offset
// Returns: All notifications with actor info, paginated
// Usage: Notification history page
// Performance: Uses idx_notification_recipient
func (q *Queries) GetAllNotifications(ctx context.Context, arg GetAllNotificationsParams) ([]GetAllNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getAllNotifications, arg.RecipientUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllNotificationsRow{}
	for rows.Next() {
		var i GetAllNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ReferenceID,
			&i.ReferenceType,
			&i.IsRead,
			&i.CreatedAt,
			&i.ActorID,
			&i.ActorUsername,
			&i.ActorProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationWithDetails = `-- name: GetNotificationWithDetails :one
SELECT
    n.id, n.recipient_user_id, n.actor_user_id, n.type, n.reference_id, n.reference_type, n.is_read, n.created_at,
    actor.id as actor_id,
    actor.username as actor_username,
    actor.profile_picture_url as actor_profile_picture,
    recipient.id as recipient_id,
    recipient.username as recipient_username
FROM notification n
JOIN "user" actor ON n.actor_user_id = actor.id
JOIN "user" recipient ON n.recipient_user_id = recipient.id
WHERE n.id = $1
`

type GetNotificationWithDetailsRow struct {
	ID                  string    `json:"id"`
	RecipientUserID     string    `json:"recipient_user_id"`
	ActorUserID         string    `json:"actor_user_id"`
	Type                string    `json:"type"`
	ReferenceID         *string   `json:"reference_id"`
	ReferenceType       *string   `json:"reference_type"`
	IsRead              *bool     `json:"is_read"`
	CreatedAt           time.Time `json:"created_at"`
	ActorID             string    `json:"actor_id"`
	ActorUsername       string    `json:"actor_username"`
	ActorProfilePicture *string   `json:"actor_profile_picture"`
	RecipientID         string    `json:"recipient_id"`
	RecipientUsername   string    `json:"recipient_username"`
}

// ----------------------------------------------------------------------------
// 11. GET NOTIFICATION WITH DETAILS
// ----------------------------------------------------------------------------
// Parameters: $1 = notification_id
// Returns: Notification with full context (actor, reference object)
// Usage: Display rich notification with post/comment preview
// Note: This is a base query - you may need to join additional tables
//
//	based on reference_type (post, comment, etc.)
func (q *Queries) GetNotificationWithDetails(ctx context.Context, id string) (GetNotificationWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getNotificationWithDetails, id)
	var i GetNotificationWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.RecipientUserID,
		&i.ActorUserID,
		&i.Type,
		&i.ReferenceID,
		&i.ReferenceType,
		&i.IsRead,
		&i.CreatedAt,
		&i.ActorID,
		&i.ActorUsername,
		&i.ActorProfilePicture,
		&i.RecipientID,
		&i.RecipientUsername,
	)
	return i, err
}

const getNotificationsByType = `-- name: GetNotificationsByType :many
SELECT
    n.id,
    n.type,
    n.reference_id,
    n.reference_type,
    n.is_read,
    n.created_at,
    u.id as actor_id,
    u.username as actor_username,
    u.profile_picture_url as actor_profile_picture
FROM notification n
JOIN "user" u ON n.actor_user_id = u.id
WHERE n.recipient_user_id = $1 AND n.type = $2
ORDER BY n.created_at DESC
LIMIT $3 OFFSET $4
`

type GetNotificationsByTypeParams struct {
	RecipientUserID string `json:"recipient_user_id"`
	Type            string `json:"type"`
	Limit           int32  `json:"limit"`
	Offset          int32  `json:"offset"`
}

type GetNotificationsByTypeRow struct {
	ID                  string    `json:"id"`
	Type                string    `json:"type"`
	ReferenceID         *string   `json:"reference_id"`
	ReferenceType       *string   `json:"reference_type"`
	IsRead              *bool     `json:"is_read"`
	CreatedAt           time.Time `json:"created_at"`
	ActorID             string    `json:"actor_id"`
	ActorUsername       string    `json:"actor_username"`
	ActorProfilePicture *string   `json:"actor_profile_picture"`
}

// ----------------------------------------------------------------------------
// 9. GET NOTIFICATIONS BY TYPE
// ----------------------------------------------------------------------------
// Parameters: $1 = recipient_user_id, $2 = type, $3 = limit, $4 = offset
// Returns: Notifications filtered by type
// Usage: Filter notifications (e.g., show only 'like' notifications)
// Performance: Uses idx_notification_type
func (q *Queries) GetNotificationsByType(ctx context.Context, arg GetNotificationsByTypeParams) ([]GetNotificationsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsByType,
		arg.RecipientUserID,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNotificationsByTypeRow{}
	for rows.Next() {
		var i GetNotificationsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ReferenceID,
			&i.ReferenceType,
			&i.IsRead,
			&i.CreatedAt,
			&i.ActorID,
			&i.ActorUsername,
			&i.ActorProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadNotificationCount = `-- name: GetUnreadNotificationCount :one
SELECT COUNT(*) as unread_count
FROM notification
WHERE recipient_user_id = $1 AND is_read = false
`

// ----------------------------------------------------------------------------
// 8. GET UNREAD NOTIFICATION COUNT
// ----------------------------------------------------------------------------
// Parameters: $1 = recipient_user_id
// Returns: Number of unread notifications
// Usage: Display badge count on notification bell
func (q *Queries) GetUnreadNotificationCount(ctx context.Context, recipientUserID string) (int64, error) {
	row := q.db.QueryRow(ctx, getUnreadNotificationCount, recipientUserID)
	var unread_count int64
	err := row.Scan(&unread_count)
	return unread_count, err
}

const getUnreadNotifications = `-- name: GetUnreadNotifications :many
SELECT
    n.id,
    n.type,
    n.reference_id,
    n.reference_type,
    n.created_at,
    u.id as actor_id,
    u.username as actor_username,
    u.profile_picture_url as actor_profile_picture
FROM notification n
JOIN "user" u ON n.actor_user_id = u.id
WHERE n.recipient_user_id = $1 AND n.is_read = false
ORDER BY n.created_at DESC
LIMIT $2
`

type GetUnreadNotificationsParams struct {
	RecipientUserID string `json:"recipient_user_id"`
	Limit           int32  `json:"limit"`
}

type GetUnreadNotificationsRow struct {
	ID                  string    `json:"id"`
	Type                string    `json:"type"`
	ReferenceID         *string   `json:"reference_id"`
	ReferenceType       *string   `json:"reference_type"`
	CreatedAt           time.Time `json:"created_at"`
	ActorID             string    `json:"actor_id"`
	ActorUsername       string    `json:"actor_username"`
	ActorProfilePicture *string   `json:"actor_profile_picture"`
}

// ----------------------------------------------------------------------------
// 2. GET UNREAD NOTIFICATIONS
// ----------------------------------------------------------------------------
// Parameters: $1 = recipient_user_id, $2 = limit
// Returns: Unread notifications with actor info
// Usage: Show notification dropdown/badge
// Performance: Uses idx_notification_is_read
func (q *Queries) GetUnreadNotifications(ctx context.Context, arg GetUnreadNotificationsParams) ([]GetUnreadNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getUnreadNotifications, arg.RecipientUserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnreadNotificationsRow{}
	for rows.Next() {
		var i GetUnreadNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ReferenceID,
			&i.ReferenceType,
			&i.CreatedAt,
			&i.ActorID,
			&i.ActorUsername,
			&i.ActorProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsAsRead = `-- name: MarkAllNotificationsAsRead :many
UPDATE notification
SET is_read = true
WHERE recipient_user_id = $1 AND is_read = false
RETURNING id
`

// ----------------------------------------------------------------------------
// 6. MARK ALL NOTIFICATIONS AS READ
// ----------------------------------------------------------------------------
// Parameters: $1 = recipient_user_id
// Returns: Number of updated notifications
// Usage: "Mark all as read" button
func (q *Queries) MarkAllNotificationsAsRead(ctx context.Context, recipientUserID string) ([]string, error) {
	rows, err := q.db.Query(ctx, markAllNotificationsAsRead, recipientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMultipleNotificationsAsRead = `-- name: MarkMultipleNotificationsAsRead :many
UPDATE notification
SET is_read = true
WHERE recipient_user_id = $1 AND id = ANY($2)
RETURNING id
`

type MarkMultipleNotificationsAsReadParams struct {
	RecipientUserID string `json:"recipient_user_id"`
	ID              string `json:"id"`
}

// ----------------------------------------------------------------------------
// 5. MARK MULTIPLE NOTIFICATIONS AS READ
// ----------------------------------------------------------------------------
// Parameters: $1 = recipient_user_id, $2 = array of notification_ids
// Returns: Number of updated notifications
// Usage: "Mark all as read" or batch mark
// Note: ANY($2) allows passing array of IDs
func (q *Queries) MarkMultipleNotificationsAsRead(ctx context.Context, arg MarkMultipleNotificationsAsReadParams) ([]string, error) {
	rows, err := q.db.Query(ctx, markMultipleNotificationsAsRead, arg.RecipientUserID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :one
UPDATE notification
SET is_read = true
WHERE id = $1 AND recipient_user_id = $2
RETURNING id, is_read
`

type MarkNotificationAsReadParams struct {
	ID              string `json:"id"`
	RecipientUserID string `json:"recipient_user_id"`
}

type MarkNotificationAsReadRow struct {
	ID     string `json:"id"`
	IsRead *bool  `json:"is_read"`
}

// ----------------------------------------------------------------------------
// 4. MARK NOTIFICATION AS READ
// ----------------------------------------------------------------------------
// Parameters: $1 = notification_id, $2 = recipient_user_id
// Returns: Updated notification
// Usage: User clicks on a notification
// Note: Includes recipient_user_id check for security
func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) (MarkNotificationAsReadRow, error) {
	row := q.db.QueryRow(ctx, markNotificationAsRead, arg.ID, arg.RecipientUserID)
	var i MarkNotificationAsReadRow
	err := row.Scan(&i.ID, &i.IsRead)
	return i, err
}
