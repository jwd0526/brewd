// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: interaction.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addComment = `-- name: AddComment :one

INSERT INTO comment (id, post_id, parent_comment_id, owner_id, content)
VALUES ($1, $2, NULL, $3, $4)
RETURNING id, post_id, parent_comment_id, owner_id, content, created_at
`

type AddCommentParams struct {
	ID      string `json:"id"`
	PostID  string `json:"post_id"`
	OwnerID string `json:"owner_id"`
	Content string `json:"content"`
}

type AddCommentRow struct {
	ID              string    `json:"id"`
	PostID          string    `json:"post_id"`
	ParentCommentID *string   `json:"parent_comment_id"`
	OwnerID         string    `json:"owner_id"`
	Content         string    `json:"content"`
	CreatedAt       time.Time `json:"created_at"`
}

// ----------------------------------------------------------------------------
// COMMENTS
// ----------------------------------------------------------------------------
// 9. ADD COMMENT (Top-level)
// Parameters: $1 = id (ULID), $2 = post_id, $3 = owner_id, $4 = content
// Returns: Created comment record
// Usage: User comments on a post
// Note: parent_comment_id is NULL for top-level comments
func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (AddCommentRow, error) {
	row := q.db.QueryRow(ctx, addComment,
		arg.ID,
		arg.PostID,
		arg.OwnerID,
		arg.Content,
	)
	var i AddCommentRow
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.ParentCommentID,
		&i.OwnerID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const addReply = `-- name: AddReply :one
INSERT INTO comment (id, post_id, parent_comment_id, owner_id, content)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, post_id, parent_comment_id, owner_id, content, created_at
`

type AddReplyParams struct {
	ID              string  `json:"id"`
	PostID          string  `json:"post_id"`
	ParentCommentID *string `json:"parent_comment_id"`
	OwnerID         string  `json:"owner_id"`
	Content         string  `json:"content"`
}

type AddReplyRow struct {
	ID              string    `json:"id"`
	PostID          string    `json:"post_id"`
	ParentCommentID *string   `json:"parent_comment_id"`
	OwnerID         string    `json:"owner_id"`
	Content         string    `json:"content"`
	CreatedAt       time.Time `json:"created_at"`
}

// 10. ADD REPLY (Threaded comment)
// Parameters: $1 = id (ULID), $2 = post_id, $3 = parent_comment_id,
//
//	$4 = owner_id, $5 = content
//
// Returns: Created reply record
// Usage: User replies to an existing comment
func (q *Queries) AddReply(ctx context.Context, arg AddReplyParams) (AddReplyRow, error) {
	row := q.db.QueryRow(ctx, addReply,
		arg.ID,
		arg.PostID,
		arg.ParentCommentID,
		arg.OwnerID,
		arg.Content,
	)
	var i AddReplyRow
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.ParentCommentID,
		&i.OwnerID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const checkUserLikedPost = `-- name: CheckUserLikedPost :one
SELECT EXISTS (
    SELECT 1 FROM post_likes
    WHERE post_id = $1 AND user_id = $2
) as liked
`

type CheckUserLikedPostParams struct {
	PostID string `json:"post_id"`
	UserID string `json:"user_id"`
}

// 5. CHECK IF USER LIKED POST
// Parameters: $1 = post_id, $2 = user_id
// Returns: Boolean (true if user liked this post)
// Usage: Show liked/unliked state in UI
func (q *Queries) CheckUserLikedPost(ctx context.Context, arg CheckUserLikedPostParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserLikedPost, arg.PostID, arg.UserID)
	var liked bool
	err := row.Scan(&liked)
	return liked, err
}

const deleteComment = `-- name: DeleteComment :one

DELETE FROM comment
WHERE id = $1
RETURNING id
`

// 14. DELETE COMMENT
// Parameters: $1 = comment_id
// Returns: Deleted comment id
// Usage: User deletes their comment
// Note: CASCADE will also delete replies (see comment.sql schema)
func (q *Queries) DeleteComment(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, deleteComment, id)
	err := row.Scan(&id)
	return id, err
}

const getCommentCount = `-- name: GetCommentCount :one
SELECT COUNT(*) as comment_count
FROM comment
WHERE post_id = $1
`

// 15. GET COMMENT COUNT FOR POST
// Parameters: $1 = post_id
// Returns: Total number of comments (including replies)
// Usage: Display "X comments" on post preview
func (q *Queries) GetCommentCount(ctx context.Context, postID string) (int64, error) {
	row := q.db.QueryRow(ctx, getCommentCount, postID)
	var comment_count int64
	err := row.Scan(&comment_count)
	return comment_count, err
}

const getCommentLikeCount = `-- name: GetCommentLikeCount :one

SELECT COUNT(*) as like_count
FROM comment_likes
WHERE comment_id = $1
`

// 8. GET COMMENT LIKE COUNT
// Parameters: $1 = comment_id
// Returns: Number of likes on a comment
// Usage: Display like count on comments
func (q *Queries) GetCommentLikeCount(ctx context.Context, commentID string) (int64, error) {
	row := q.db.QueryRow(ctx, getCommentLikeCount, commentID)
	var like_count int64
	err := row.Scan(&like_count)
	return like_count, err
}

const getCommentsForPost = `-- name: GetCommentsForPost :many
SELECT
    c.id,
    c.content,
    c.created_at,
    c.updated_at,
    u.id as owner_id,
    u.username,
    u.profile_picture_url,
    COUNT(DISTINCT replies.id) as reply_count,
    COUNT(DISTINCT cl.user_id) as like_count
FROM comment c
JOIN "user" u ON c.owner_id = u.id
LEFT JOIN comment replies ON c.id = replies.parent_comment_id
LEFT JOIN comment_likes cl ON c.id = cl.comment_id
WHERE c.post_id = $1 AND c.parent_comment_id IS NULL
GROUP BY c.id, u.id, u.username, u.profile_picture_url
ORDER BY c.created_at ASC
`

type GetCommentsForPostRow struct {
	ID                string    `json:"id"`
	Content           string    `json:"content"`
	CreatedAt         time.Time `json:"created_at"`
	UpdatedAt         time.Time `json:"updated_at"`
	OwnerID           string    `json:"owner_id"`
	Username          string    `json:"username"`
	ProfilePictureUrl *string   `json:"profile_picture_url"`
	ReplyCount        int64     `json:"reply_count"`
	LikeCount         int64     `json:"like_count"`
}

// 11. GET COMMENTS FOR POST (Top-level only)
// Parameters: $1 = post_id
// Returns: Top-level comments with user info, reply count, like count
// Usage: Display comment section (fetch replies separately)
// Performance: Uses idx_comment_post_id and idx_comment_parent_comment_id
func (q *Queries) GetCommentsForPost(ctx context.Context, postID string) ([]GetCommentsForPostRow, error) {
	rows, err := q.db.Query(ctx, getCommentsForPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommentsForPostRow{}
	for rows.Next() {
		var i GetCommentsForPostRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.ReplyCount,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostLikeCount = `-- name: GetPostLikeCount :one
SELECT COUNT(*) as like_count
FROM post_likes
WHERE post_id = $1
`

// 4. GET POST LIKE COUNT
// Parameters: $1 = post_id
// Returns: Number of likes on a post
// Usage: Display like count
func (q *Queries) GetPostLikeCount(ctx context.Context, postID string) (int64, error) {
	row := q.db.QueryRow(ctx, getPostLikeCount, postID)
	var like_count int64
	err := row.Scan(&like_count)
	return like_count, err
}

const getPostLikers = `-- name: GetPostLikers :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    pl.created_at as liked_at
FROM "user" u
JOIN post_likes pl ON u.id = pl.user_id
WHERE pl.post_id = $1
ORDER BY pl.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPostLikersParams struct {
	PostID string `json:"post_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetPostLikersRow struct {
	ID                string    `json:"id"`
	Username          string    `json:"username"`
	ProfilePictureUrl *string   `json:"profile_picture_url"`
	LikedAt           time.Time `json:"liked_at"`
}

// 3. GET USERS WHO LIKED A POST
// Parameters: $1 = post_id, $2 = limit, $3 = offset
// Returns: List of users who liked this post
// Usage: Display "Liked by X, Y, and 23 others"
// Performance: Uses idx_post_likes_post_id
func (q *Queries) GetPostLikers(ctx context.Context, arg GetPostLikersParams) ([]GetPostLikersRow, error) {
	rows, err := q.db.Query(ctx, getPostLikers, arg.PostID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostLikersRow{}
	for rows.Next() {
		var i GetPostLikersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.LikedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsWhereUserIsTagged = `-- name: GetPostsWhereUserIsTagged :many
SELECT
    p.id,
    p.title,
    p.description,
    p.rating,
    p.created_at,
    u.id as owner_id,
    u.username,
    u.profile_picture_url
FROM post p
JOIN post_user_tags t ON p.id = t.post_id
JOIN "user" u ON p.owner_id = u.id
WHERE t.user_id = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPostsWhereUserIsTaggedParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetPostsWhereUserIsTaggedRow struct {
	ID                string         `json:"id"`
	Title             string         `json:"title"`
	Description       *string        `json:"description"`
	Rating            pgtype.Numeric `json:"rating"`
	CreatedAt         time.Time      `json:"created_at"`
	OwnerID           string         `json:"owner_id"`
	Username          string         `json:"username"`
	ProfilePictureUrl *string        `json:"profile_picture_url"`
}

// 20. GET POSTS WHERE USER IS TAGGED
// Parameters: $1 = user_id, $2 = limit, $3 = offset
// Returns: Posts where user has been tagged
// Usage: "Posts you're tagged in" section on profile
func (q *Queries) GetPostsWhereUserIsTagged(ctx context.Context, arg GetPostsWhereUserIsTaggedParams) ([]GetPostsWhereUserIsTaggedRow, error) {
	rows, err := q.db.Query(ctx, getPostsWhereUserIsTagged, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsWhereUserIsTaggedRow{}
	for rows.Next() {
		var i GetPostsWhereUserIsTaggedRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Rating,
			&i.CreatedAt,
			&i.OwnerID,
			&i.Username,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepliesToComment = `-- name: GetRepliesToComment :many
SELECT
    c.id,
    c.content,
    c.created_at,
    c.updated_at,
    u.id as owner_id,
    u.username,
    u.profile_picture_url,
    COUNT(DISTINCT cl.user_id) as like_count
FROM comment c
JOIN "user" u ON c.owner_id = u.id
LEFT JOIN comment_likes cl ON c.id = cl.comment_id
WHERE c.parent_comment_id = $1
GROUP BY c.id, u.id, u.username, u.profile_picture_url
ORDER BY c.created_at ASC
`

type GetRepliesToCommentRow struct {
	ID                string    `json:"id"`
	Content           string    `json:"content"`
	CreatedAt         time.Time `json:"created_at"`
	UpdatedAt         time.Time `json:"updated_at"`
	OwnerID           string    `json:"owner_id"`
	Username          string    `json:"username"`
	ProfilePictureUrl *string   `json:"profile_picture_url"`
	LikeCount         int64     `json:"like_count"`
}

// 12. GET REPLIES TO COMMENT
// Parameters: $1 = parent_comment_id
// Returns: Replies to a specific comment with user info and like count
// Usage: Load threaded replies (nested comments)
// Performance: Uses idx_comment_parent_comment_id
func (q *Queries) GetRepliesToComment(ctx context.Context, parentCommentID *string) ([]GetRepliesToCommentRow, error) {
	rows, err := q.db.Query(ctx, getRepliesToComment, parentCommentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRepliesToCommentRow{}
	for rows.Next() {
		var i GetRepliesToCommentRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopLevelCommentCount = `-- name: GetTopLevelCommentCount :one
SELECT COUNT(*) as comment_count
FROM comment
WHERE post_id = $1 AND parent_comment_id IS NULL
`

// 16. GET TOP-LEVEL COMMENT COUNT FOR POST
// Parameters: $1 = post_id
// Returns: Number of top-level comments only (excludes replies)
// Usage: Display "X comments" excluding nested replies
func (q *Queries) GetTopLevelCommentCount(ctx context.Context, postID string) (int64, error) {
	row := q.db.QueryRow(ctx, getTopLevelCommentCount, postID)
	var comment_count int64
	err := row.Scan(&comment_count)
	return comment_count, err
}

const getUsersTaggedInPost = `-- name: GetUsersTaggedInPost :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url
FROM "user" u
JOIN post_user_tags t ON u.id = t.user_id
WHERE t.post_id = $1
ORDER BY u.username
`

type GetUsersTaggedInPostRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
}

// 19. GET USERS TAGGED IN POST
// Parameters: $1 = post_id
// Returns: List of users tagged in this post
// Usage: Display "with X and Y" in post
func (q *Queries) GetUsersTaggedInPost(ctx context.Context, postID string) ([]GetUsersTaggedInPostRow, error) {
	rows, err := q.db.Query(ctx, getUsersTaggedInPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersTaggedInPostRow{}
	for rows.Next() {
		var i GetUsersTaggedInPostRow
		if err := rows.Scan(&i.ID, &i.Username, &i.ProfilePictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const likeComment = `-- name: LikeComment :one

INSERT INTO comment_likes (comment_id, user_id, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT (comment_id, user_id) DO NOTHING
RETURNING comment_id, user_id, created_at
`

type LikeCommentParams struct {
	CommentID string `json:"comment_id"`
	UserID    string `json:"user_id"`
}

// ----------------------------------------------------------------------------
// COMMENT LIKES
// ----------------------------------------------------------------------------
// 6. LIKE A COMMENT
// Parameters: $1 = comment_id, $2 = user_id
// Returns: Created like record
// Usage: User likes a comment
// Note: ON CONFLICT makes this idempotent
func (q *Queries) LikeComment(ctx context.Context, arg LikeCommentParams) (CommentLike, error) {
	row := q.db.QueryRow(ctx, likeComment, arg.CommentID, arg.UserID)
	var i CommentLike
	err := row.Scan(&i.CommentID, &i.UserID, &i.CreatedAt)
	return i, err
}

const likePost = `-- name: LikePost :one



INSERT INTO post_likes (post_id, user_id, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT (post_id, user_id) DO NOTHING
RETURNING post_id, user_id, created_at
`

type LikePostParams struct {
	PostID string `json:"post_id"`
	UserID string `json:"user_id"`
}

// ============================================================================
// INTERACTION QUERIES
// ============================================================================
// Operations for likes and comments on posts and comments
// ----------------------------------------------------------------------------
// POST LIKES
// ----------------------------------------------------------------------------
// 1. LIKE A POST
// Parameters: $1 = post_id, $2 = user_id
// Returns: Created like record
// Usage: User likes a post
// Note: ON CONFLICT makes this idempotent (can call multiple times safely)
func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (PostLike, error) {
	row := q.db.QueryRow(ctx, likePost, arg.PostID, arg.UserID)
	var i PostLike
	err := row.Scan(&i.PostID, &i.UserID, &i.CreatedAt)
	return i, err
}

const tagUserInPost = `-- name: TagUserInPost :one

INSERT INTO post_user_tags (post_id, user_id, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT (post_id, user_id) DO NOTHING
RETURNING post_id, user_id, created_at
`

type TagUserInPostParams struct {
	PostID string `json:"post_id"`
	UserID string `json:"user_id"`
}

// ----------------------------------------------------------------------------
// POST USER TAGS
// ----------------------------------------------------------------------------
// 17. TAG USER IN POST
// Parameters: $1 = post_id, $2 = user_id
// Returns: Created tag record
// Usage: Tag a friend in a coffee post
// Note: Should trigger notification (see notification.sql)
func (q *Queries) TagUserInPost(ctx context.Context, arg TagUserInPostParams) (PostUserTag, error) {
	row := q.db.QueryRow(ctx, tagUserInPost, arg.PostID, arg.UserID)
	var i PostUserTag
	err := row.Scan(&i.PostID, &i.UserID, &i.CreatedAt)
	return i, err
}

const unlikeComment = `-- name: UnlikeComment :one
DELETE FROM comment_likes
WHERE comment_id = $1 AND user_id = $2
RETURNING comment_id, user_id
`

type UnlikeCommentParams struct {
	CommentID string `json:"comment_id"`
	UserID    string `json:"user_id"`
}

type UnlikeCommentRow struct {
	CommentID string `json:"comment_id"`
	UserID    string `json:"user_id"`
}

// 7. UNLIKE A COMMENT
// Parameters: $1 = comment_id, $2 = user_id
// Returns: Deleted like record
// Usage: User removes their like from a comment
func (q *Queries) UnlikeComment(ctx context.Context, arg UnlikeCommentParams) (UnlikeCommentRow, error) {
	row := q.db.QueryRow(ctx, unlikeComment, arg.CommentID, arg.UserID)
	var i UnlikeCommentRow
	err := row.Scan(&i.CommentID, &i.UserID)
	return i, err
}

const unlikePost = `-- name: UnlikePost :one
DELETE FROM post_likes
WHERE post_id = $1 AND user_id = $2
RETURNING post_id, user_id
`

type UnlikePostParams struct {
	PostID string `json:"post_id"`
	UserID string `json:"user_id"`
}

type UnlikePostRow struct {
	PostID string `json:"post_id"`
	UserID string `json:"user_id"`
}

// 2. UNLIKE A POST
// Parameters: $1 = post_id, $2 = user_id
// Returns: Deleted like record
// Usage: User removes their like from a post
func (q *Queries) UnlikePost(ctx context.Context, arg UnlikePostParams) (UnlikePostRow, error) {
	row := q.db.QueryRow(ctx, unlikePost, arg.PostID, arg.UserID)
	var i UnlikePostRow
	err := row.Scan(&i.PostID, &i.UserID)
	return i, err
}

const untagUserFromPost = `-- name: UntagUserFromPost :one
DELETE FROM post_user_tags
WHERE post_id = $1 AND user_id = $2
RETURNING post_id, user_id
`

type UntagUserFromPostParams struct {
	PostID string `json:"post_id"`
	UserID string `json:"user_id"`
}

type UntagUserFromPostRow struct {
	PostID string `json:"post_id"`
	UserID string `json:"user_id"`
}

// 18. UNTAG USER FROM POST
// Parameters: $1 = post_id, $2 = user_id
// Returns: Deleted tag record
// Usage: Remove tag from post
func (q *Queries) UntagUserFromPost(ctx context.Context, arg UntagUserFromPostParams) (UntagUserFromPostRow, error) {
	row := q.db.QueryRow(ctx, untagUserFromPost, arg.PostID, arg.UserID)
	var i UntagUserFromPostRow
	err := row.Scan(&i.PostID, &i.UserID)
	return i, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE comment
SET
    content = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, post_id, parent_comment_id, owner_id, content, updated_at
`

type UpdateCommentParams struct {
	ID      string `json:"id"`
	Content string `json:"content"`
}

type UpdateCommentRow struct {
	ID              string    `json:"id"`
	PostID          string    `json:"post_id"`
	ParentCommentID *string   `json:"parent_comment_id"`
	OwnerID         string    `json:"owner_id"`
	Content         string    `json:"content"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// 13. UPDATE COMMENT
// Parameters: $1 = comment_id, $2 = content
// Returns: Updated comment record
// Usage: User edits their comment
func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (UpdateCommentRow, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.ID, arg.Content)
	var i UpdateCommentRow
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.ParentCommentID,
		&i.OwnerID,
		&i.Content,
		&i.UpdatedAt,
	)
	return i, err
}
