// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: post.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMediaToPost = `-- name: AddMediaToPost :one
INSERT INTO media (id, post_id, url, type, display_order)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, post_id, url, type, display_order, created_at
`

type AddMediaToPostParams struct {
	ID           string `json:"id"`
	PostID       string `json:"post_id"`
	Url          string `json:"url"`
	Type         string `json:"type"`
	DisplayOrder *int32 `json:"display_order"`
}

// ----------------------------------------------------------------------------
// 9. ADD MEDIA TO POST
// ----------------------------------------------------------------------------
// Parameters: $1 = id (ULID), $2 = post_id, $3 = url, $4 = type, $5 = display_order
// Returns: Created media record
// Usage: Attach photos/videos to a post
func (q *Queries) AddMediaToPost(ctx context.Context, arg AddMediaToPostParams) (Medium, error) {
	row := q.db.QueryRow(ctx, addMediaToPost,
		arg.ID,
		arg.PostID,
		arg.Url,
		arg.Type,
		arg.DisplayOrder,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Url,
		&i.Type,
		&i.DisplayOrder,
		&i.CreatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one


INSERT INTO post (id, owner_id, brew_id, title, description, rating, visibility)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, owner_id, brew_id, title, description, rating, visibility, created_at, updated_at
`

type CreatePostParams struct {
	ID          string         `json:"id"`
	OwnerID     string         `json:"owner_id"`
	BrewID      *string        `json:"brew_id"`
	Title       string         `json:"title"`
	Description *string        `json:"description"`
	Rating      pgtype.Numeric `json:"rating"`
	Visibility  *string        `json:"visibility"`
}

// ============================================================================
// POST QUERIES
// ============================================================================
// Operations for posts: create, read, feed generation, and user posts
// ----------------------------------------------------------------------------
// 1. CREATE POST
// ----------------------------------------------------------------------------
// Parameters: $1 = id (ULID), $2 = owner_id, $3 = brew_id, $4 = title,
//
//	$5 = description, $6 = rating, $7 = visibility
//
// Returns: The created post record
// Usage: User creates a new coffee brew post
func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.ID,
		arg.OwnerID,
		arg.BrewID,
		arg.Title,
		arg.Description,
		arg.Rating,
		arg.Visibility,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BrewID,
		&i.Title,
		&i.Description,
		&i.Rating,
		&i.Visibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :one
DELETE FROM post
WHERE id = $1
RETURNING id
`

// ----------------------------------------------------------------------------
// 7. DELETE POST
// ----------------------------------------------------------------------------
// Parameters: $1 = post_id
// Returns: Deleted post id
// Usage: User deletes their post
// Note: CASCADE will also delete related media, likes, comments
func (q *Queries) DeletePost(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, deletePost, id)
	err := row.Scan(&id)
	return id, err
}

const getMediaForPost = `-- name: GetMediaForPost :many
SELECT id, post_id, url, type, display_order, created_at
FROM media
WHERE post_id = $1
ORDER BY display_order
`

// ----------------------------------------------------------------------------
// 10. GET MEDIA FOR POST
// ----------------------------------------------------------------------------
// Parameters: $1 = post_id
// Returns: All media items for a post, ordered by display_order
// Usage: Display post images/videos
func (q *Queries) GetMediaForPost(ctx context.Context, postID string) ([]Medium, error) {
	rows, err := q.db.Query(ctx, getMediaForPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medium{}
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.Url,
			&i.Type,
			&i.DisplayOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostWithDetails = `-- name: GetPostWithDetails :one
SELECT
    p.id, p.owner_id, p.brew_id, p.title, p.description, p.rating, p.visibility, p.created_at, p.updated_at,
    u.username,
    u.profile_picture_url,
    b.name as brew_name,
    b.brew_method,
    b.bean_origin,
    b.roaster,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count,
    ARRAY_AGG(jsonb_build_object(
        'id', m.id,
        'url', m.url,
        'type', m.type,
        'display_order', m.display_order
    ) ORDER BY m.display_order) FILTER (WHERE m.id IS NOT NULL) as media
FROM post p
JOIN "user" u ON p.owner_id = u.id
LEFT JOIN brew b ON p.brew_id = b.id
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
LEFT JOIN media m ON p.id = m.post_id
WHERE p.id = $1
GROUP BY p.id, u.id, b.id
`

type GetPostWithDetailsRow struct {
	ID                string         `json:"id"`
	OwnerID           string         `json:"owner_id"`
	BrewID            *string        `json:"brew_id"`
	Title             string         `json:"title"`
	Description       *string        `json:"description"`
	Rating            pgtype.Numeric `json:"rating"`
	Visibility        *string        `json:"visibility"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	Username          string         `json:"username"`
	ProfilePictureUrl *string        `json:"profile_picture_url"`
	BrewName          *string        `json:"brew_name"`
	BrewMethod        *string        `json:"brew_method"`
	BeanOrigin        *string        `json:"bean_origin"`
	Roaster           *string        `json:"roaster"`
	LikeCount         int64          `json:"like_count"`
	CommentCount      int64          `json:"comment_count"`
	Media             interface{}    `json:"media"`
}

// ----------------------------------------------------------------------------
// 2. GET SINGLE POST WITH FULL DETAILS
// ----------------------------------------------------------------------------
// Parameters: $1 = post_id
// Returns: Post with owner info, brew details, media, like count, comment count
// Usage: Display detailed post view
// Performance: Multiple LEFT JOINs, uses multiple indexes
func (q *Queries) GetPostWithDetails(ctx context.Context, id string) (GetPostWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getPostWithDetails, id)
	var i GetPostWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BrewID,
		&i.Title,
		&i.Description,
		&i.Rating,
		&i.Visibility,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.ProfilePictureUrl,
		&i.BrewName,
		&i.BrewMethod,
		&i.BeanOrigin,
		&i.Roaster,
		&i.LikeCount,
		&i.CommentCount,
		&i.Media,
	)
	return i, err
}

const getPostsByBrew = `-- name: GetPostsByBrew :many
SELECT
    p.id,
    p.title,
    p.description,
    p.rating,
    p.created_at,
    u.id as owner_id,
    u.username,
    u.profile_picture_url,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count
FROM post p
JOIN "user" u ON p.owner_id = u.id
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
WHERE p.brew_id = $1
    AND p.visibility = 'public'
GROUP BY p.id, u.id, u.username, u.profile_picture_url
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPostsByBrewParams struct {
	BrewID *string `json:"brew_id"`
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
}

type GetPostsByBrewRow struct {
	ID                string         `json:"id"`
	Title             string         `json:"title"`
	Description       *string        `json:"description"`
	Rating            pgtype.Numeric `json:"rating"`
	CreatedAt         time.Time      `json:"created_at"`
	OwnerID           string         `json:"owner_id"`
	Username          string         `json:"username"`
	ProfilePictureUrl *string        `json:"profile_picture_url"`
	LikeCount         int64          `json:"like_count"`
	CommentCount      int64          `json:"comment_count"`
}

// ----------------------------------------------------------------------------
// 8. GET POSTS BY BREW
// ----------------------------------------------------------------------------
// Parameters: $1 = brew_id, $2 = limit, $3 = offset
// Returns: All posts using a specific brew
// Usage: View all posts for a particular coffee brew
// Performance: Uses idx_post_brew_id
func (q *Queries) GetPostsByBrew(ctx context.Context, arg GetPostsByBrewParams) ([]GetPostsByBrewRow, error) {
	rows, err := q.db.Query(ctx, getPostsByBrew, arg.BrewID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsByBrewRow{}
	for rows.Next() {
		var i GetPostsByBrewRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Rating,
			&i.CreatedAt,
			&i.OwnerID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.LikeCount,
			&i.CommentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicPosts = `-- name: GetPublicPosts :many
SELECT
    p.id,
    p.title,
    p.description,
    p.rating,
    p.created_at,
    u.id as owner_id,
    u.username,
    u.profile_picture_url,
    b.name as brew_name,
    b.brew_method,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count
FROM post p
JOIN "user" u ON p.owner_id = u.id
LEFT JOIN brew b ON p.brew_id = b.id
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
WHERE p.visibility = 'public'
GROUP BY p.id, u.id, u.username, u.profile_picture_url, b.name, b.brew_method
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type GetPublicPostsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPublicPostsRow struct {
	ID                string         `json:"id"`
	Title             string         `json:"title"`
	Description       *string        `json:"description"`
	Rating            pgtype.Numeric `json:"rating"`
	CreatedAt         time.Time      `json:"created_at"`
	OwnerID           string         `json:"owner_id"`
	Username          string         `json:"username"`
	ProfilePictureUrl *string        `json:"profile_picture_url"`
	BrewName          *string        `json:"brew_name"`
	BrewMethod        *string        `json:"brew_method"`
	LikeCount         int64          `json:"like_count"`
	CommentCount      int64          `json:"comment_count"`
}

// ----------------------------------------------------------------------------
// 5. GET PUBLIC POSTS (Discovery Feed)
// ----------------------------------------------------------------------------
// Parameters: $1 = limit, $2 = offset
// Returns: Recent public posts from all users
// Usage: Public discovery feed for non-friends
// Performance: Uses idx_post_visibility
func (q *Queries) GetPublicPosts(ctx context.Context, arg GetPublicPostsParams) ([]GetPublicPostsRow, error) {
	rows, err := q.db.Query(ctx, getPublicPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublicPostsRow{}
	for rows.Next() {
		var i GetPublicPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Rating,
			&i.CreatedAt,
			&i.OwnerID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.BrewName,
			&i.BrewMethod,
			&i.LikeCount,
			&i.CommentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFeed = `-- name: GetUserFeed :many
SELECT
    p.id,
    p.title,
    p.description,
    p.rating,
    p.created_at,
    u.id as owner_id,
    u.username,
    u.profile_picture_url,
    b.name as brew_name,
    b.brew_method,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count,
    EXISTS(
        SELECT 1 FROM post_likes pl2
        WHERE pl2.post_id = p.id AND pl2.user_id = $1
    ) as liked_by_current_user
FROM post p
JOIN user_friendships f ON p.owner_id = f.friend_id
JOIN "user" u ON p.owner_id = u.id
LEFT JOIN brew b ON p.brew_id = b.id
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
WHERE f.user_id = $1
    AND f.status = 'accepted'
    AND p.visibility IN ('public', 'friends')
GROUP BY p.id, u.id, u.username, u.profile_picture_url, b.name, b.brew_method
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserFeedParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type GetUserFeedRow struct {
	ID                 string         `json:"id"`
	Title              string         `json:"title"`
	Description        *string        `json:"description"`
	Rating             pgtype.Numeric `json:"rating"`
	CreatedAt          time.Time      `json:"created_at"`
	OwnerID            string         `json:"owner_id"`
	Username           string         `json:"username"`
	ProfilePictureUrl  *string        `json:"profile_picture_url"`
	BrewName           *string        `json:"brew_name"`
	BrewMethod         *string        `json:"brew_method"`
	LikeCount          int64          `json:"like_count"`
	CommentCount       int64          `json:"comment_count"`
	LikedByCurrentUser bool           `json:"liked_by_current_user"`
}

// ----------------------------------------------------------------------------
// 3. GET USER FEED (Posts from Friends)
// ----------------------------------------------------------------------------
// Parameters: $1 = current_user_id, $2 = limit, $3 = offset
// Returns: Posts from friends, sorted by recency, with pagination
// Usage: Main feed feature - see what friends are brewing
// Performance: Uses idx_user_friendships_status and idx_post_created_at
func (q *Queries) GetUserFeed(ctx context.Context, arg GetUserFeedParams) ([]GetUserFeedRow, error) {
	rows, err := q.db.Query(ctx, getUserFeed, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserFeedRow{}
	for rows.Next() {
		var i GetUserFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Rating,
			&i.CreatedAt,
			&i.OwnerID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.BrewName,
			&i.BrewMethod,
			&i.LikeCount,
			&i.CommentCount,
			&i.LikedByCurrentUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPosts = `-- name: GetUserPosts :many
SELECT
    p.id, p.owner_id, p.brew_id, p.title, p.description, p.rating, p.visibility, p.created_at, p.updated_at,
    b.name as brew_name,
    b.brew_method,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count
FROM post p
LEFT JOIN brew b ON p.brew_id = b.id
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
WHERE p.owner_id = $1
GROUP BY p.id, b.name, b.brew_method
ORDER BY p.created_at DESC
`

type GetUserPostsRow struct {
	ID           string         `json:"id"`
	OwnerID      string         `json:"owner_id"`
	BrewID       *string        `json:"brew_id"`
	Title        string         `json:"title"`
	Description  *string        `json:"description"`
	Rating       pgtype.Numeric `json:"rating"`
	Visibility   *string        `json:"visibility"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	BrewName     *string        `json:"brew_name"`
	BrewMethod   *string        `json:"brew_method"`
	LikeCount    int64          `json:"like_count"`
	CommentCount int64          `json:"comment_count"`
}

// ----------------------------------------------------------------------------
// 4. GET USER'S OWN POSTS
// ----------------------------------------------------------------------------
// Parameters: $1 = owner_id
// Returns: All posts created by a specific user
// Usage: User profile page showing their post history
// Performance: Uses idx_post_owner_id
func (q *Queries) GetUserPosts(ctx context.Context, ownerID string) ([]GetUserPostsRow, error) {
	rows, err := q.db.Query(ctx, getUserPosts, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPostsRow{}
	for rows.Next() {
		var i GetUserPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.BrewID,
			&i.Title,
			&i.Description,
			&i.Rating,
			&i.Visibility,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BrewName,
			&i.BrewMethod,
			&i.LikeCount,
			&i.CommentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE post
SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    rating = COALESCE($4, rating),
    visibility = COALESCE($5, visibility),
    updated_at = NOW()
WHERE id = $1
RETURNING id, owner_id, brew_id, title, description, rating, visibility, created_at, updated_at
`

type UpdatePostParams struct {
	ID          string         `json:"id"`
	Title       string         `json:"title"`
	Description *string        `json:"description"`
	Rating      pgtype.Numeric `json:"rating"`
	Visibility  *string        `json:"visibility"`
}

// ----------------------------------------------------------------------------
// 6. UPDATE POST
// ----------------------------------------------------------------------------
// Parameters: $1 = post_id, $2 = title, $3 = description, $4 = rating, $5 = visibility
// Returns: Updated post record
// Usage: User edits their post
func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Rating,
		arg.Visibility,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.BrewID,
		&i.Title,
		&i.Description,
		&i.Rating,
		&i.Visibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
