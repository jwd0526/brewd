// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const getAverageEngagementByPost = `-- name: GetAverageEngagementByPost :one

SELECT
    AVG(like_count) as avg_likes_per_post,
    AVG(comment_count) as avg_comments_per_post,
    AVG(like_count + comment_count) as avg_engagement_per_post
FROM (
    SELECT
        p.id,
        COUNT(DISTINCT pl.user_id) as like_count,
        COUNT(DISTINCT c.id) as comment_count
    FROM post p
    LEFT JOIN post_likes pl ON p.id = pl.post_id
    LEFT JOIN comment c ON p.id = c.post_id
    GROUP BY p.id
) post_engagement
`

type GetAverageEngagementByPostRow struct {
	AvgLikesPerPost      float64 `json:"avg_likes_per_post"`
	AvgCommentsPerPost   float64 `json:"avg_comments_per_post"`
	AvgEngagementPerPost float64 `json:"avg_engagement_per_post"`
}

// ----------------------------------------------------------------------------
// ENGAGEMENT ANALYTICS
// ----------------------------------------------------------------------------
// 11. GET AVERAGE ENGAGEMENT BY POST
// Parameters: None
// Returns: Average likes and comments per post
// Usage: Platform health metrics
func (q *Queries) GetAverageEngagementByPost(ctx context.Context) (GetAverageEngagementByPostRow, error) {
	row := q.db.QueryRow(ctx, getAverageEngagementByPost)
	var i GetAverageEngagementByPostRow
	err := row.Scan(&i.AvgLikesPerPost, &i.AvgCommentsPerPost, &i.AvgEngagementPerPost)
	return i, err
}

const getBrewMethodDistribution = `-- name: GetBrewMethodDistribution :many

SELECT
    brew_method,
    COUNT(DISTINCT b.id) as brew_count,
    COUNT(DISTINCT p.id) as post_count,
    AVG(p.rating) as avg_rating
FROM brew b
LEFT JOIN post p ON b.id = p.brew_id
WHERE b.is_public = true AND b.brew_method IS NOT NULL
GROUP BY brew_method
ORDER BY post_count DESC
`

type GetBrewMethodDistributionRow struct {
	BrewMethod *string `json:"brew_method"`
	BrewCount  int64   `json:"brew_count"`
	PostCount  int64   `json:"post_count"`
	AvgRating  float64 `json:"avg_rating"`
}

// ----------------------------------------------------------------------------
// CONTENT ANALYTICS
// ----------------------------------------------------------------------------
// 8. GET BREW METHOD DISTRIBUTION
// Parameters: None
// Returns: Usage statistics by brew method
// Usage: "Most popular brew methods" chart
func (q *Queries) GetBrewMethodDistribution(ctx context.Context) ([]GetBrewMethodDistributionRow, error) {
	rows, err := q.db.Query(ctx, getBrewMethodDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBrewMethodDistributionRow{}
	for rows.Next() {
		var i GetBrewMethodDistributionRow
		if err := rows.Scan(
			&i.BrewMethod,
			&i.BrewCount,
			&i.PostCount,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyActiveUsers = `-- name: GetDailyActiveUsers :many
SELECT
    activity_date,
    COUNT(DISTINCT user_id) as active_users
FROM (
    SELECT owner_id as user_id, DATE(created_at) as activity_date
    FROM post
    WHERE created_at > NOW() - INTERVAL '1 day' * $1

    UNION ALL

    SELECT user_id, DATE(created_at) as activity_date
    FROM post_likes
    WHERE created_at > NOW() - INTERVAL '1 day' * $1

    UNION ALL

    SELECT owner_id as user_id, DATE(created_at) as activity_date
    FROM comment
    WHERE created_at > NOW() - INTERVAL '1 day' * $1
) activities
GROUP BY activity_date
ORDER BY activity_date DESC
`

type GetDailyActiveUsersRow struct {
	ActivityDate pgtype.Date `json:"activity_date"`
	ActiveUsers  int64       `json:"active_users"`
}

// 6. GET DAILY ACTIVE USERS
// Parameters: $1 = days_back (e.g., 7 for last week)
// Returns: Count of users who posted, liked, or commented each day
// Usage: DAU/MAU tracking
func (q *Queries) GetDailyActiveUsers(ctx context.Context, dollar_1 interface{}) ([]GetDailyActiveUsersRow, error) {
	rows, err := q.db.Query(ctx, getDailyActiveUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyActiveUsersRow{}
	for rows.Next() {
		var i GetDailyActiveUsersRow
		if err := rows.Scan(&i.ActivityDate, &i.ActiveUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEngagementRateByUser = `-- name: GetEngagementRateByUser :many
SELECT
    p.id,
    p.title,
    p.created_at,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count,
    (COUNT(DISTINCT pl.user_id) + COUNT(DISTINCT c.id)) as total_engagement
FROM post p
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
WHERE p.owner_id = $1
GROUP BY p.id
ORDER BY total_engagement DESC
`

type GetEngagementRateByUserRow struct {
	ID              string    `json:"id"`
	Title           string    `json:"title"`
	CreatedAt       time.Time `json:"created_at"`
	LikeCount       int64     `json:"like_count"`
	CommentCount    int64     `json:"comment_count"`
	TotalEngagement int32     `json:"total_engagement"`
}

// 12. GET ENGAGEMENT RATE BY USER
// Parameters: $1 = user_id
// Returns: User's posts with engagement metrics
// Usage: Show user which posts performed best
func (q *Queries) GetEngagementRateByUser(ctx context.Context, ownerID string) ([]GetEngagementRateByUserRow, error) {
	rows, err := q.db.Query(ctx, getEngagementRateByUser, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEngagementRateByUserRow{}
	for rows.Next() {
		var i GetEngagementRateByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.LikeCount,
			&i.CommentCount,
			&i.TotalEngagement,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGrowthMetrics = `-- name: GetGrowthMetrics :many
SELECT
    'users' as metric,
    COUNT(*) as count,
    DATE(joined_at) as metric_date
FROM "user"
WHERE joined_at > NOW() - INTERVAL '1 day' * $1
GROUP BY DATE(joined_at)

UNION ALL

SELECT
    'posts' as metric,
    COUNT(*) as count,
    DATE(created_at) as metric_date
FROM post
WHERE created_at > NOW() - INTERVAL '1 day' * $1
GROUP BY DATE(created_at)

UNION ALL

SELECT
    'friendships' as metric,
    COUNT(*) as count,
    DATE(created_at) as metric_date
FROM user_friendships
WHERE status = 'accepted'
    AND created_at > NOW() - INTERVAL '1 day' * $1
GROUP BY DATE(created_at)

ORDER BY metric, metric_date DESC
`

type GetGrowthMetricsRow struct {
	Metric     string      `json:"metric"`
	Count      int64       `json:"count"`
	MetricDate pgtype.Date `json:"metric_date"`
}

// 7. GET GROWTH METRICS
// Parameters: $1 = days (time window)
// Returns: New users, posts, and engagement over time
// Usage: Growth tracking dashboard
func (q *Queries) GetGrowthMetrics(ctx context.Context, dollar_1 interface{}) ([]GetGrowthMetricsRow, error) {
	rows, err := q.db.Query(ctx, getGrowthMetrics, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGrowthMetricsRow{}
	for rows.Next() {
		var i GetGrowthMetricsRow
		if err := rows.Scan(&i.Metric, &i.Count, &i.MetricDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInactiveUsers = `-- name: GetInactiveUsers :many
SELECT
    u.id,
    u.username,
    u.email,
    u.joined_at,
    MAX(GREATEST(
        COALESCE(p.created_at, '1970-01-01'::timestamp),
        COALESCE(pl.created_at, '1970-01-01'::timestamp),
        COALESCE(c.created_at, '1970-01-01'::timestamp)
    )) as last_activity
FROM "user" u
LEFT JOIN post p ON u.id = p.owner_id
LEFT JOIN post_likes pl ON u.id = pl.user_id
LEFT JOIN comment c ON u.id = c.owner_id
GROUP BY u.id
HAVING MAX(GREATEST(
    COALESCE(p.created_at, '1970-01-01'::timestamp),
    COALESCE(pl.created_at, '1970-01-01'::timestamp),
    COALESCE(c.created_at, '1970-01-01'::timestamp)
)) < NOW() - INTERVAL '1 day' * $1
ORDER BY last_activity ASC
`

type GetInactiveUsersRow struct {
	ID           string             `json:"id"`
	Username     string             `json:"username"`
	Email        string             `json:"email"`
	JoinedAt     pgtype.Timestamptz `json:"joined_at"`
	LastActivity interface{}        `json:"last_activity"`
}

// 15. GET INACTIVE USERS
// Parameters: $1 = days_inactive (e.g., 30)
// Returns: Users who haven't posted, liked, or commented recently
// Usage: Re-engagement campaigns
func (q *Queries) GetInactiveUsers(ctx context.Context, dollar_1 interface{}) ([]GetInactiveUsersRow, error) {
	rows, err := q.db.Query(ctx, getInactiveUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInactiveUsersRow{}
	for rows.Next() {
		var i GetInactiveUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.JoinedAt,
			&i.LastActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostEngagingContent = `-- name: GetMostEngagingContent :many
SELECT
    p.id,
    p.title,
    p.created_at,
    u.username,
    b.name as brew_name,
    COUNT(DISTINCT pl.user_id) as like_count,
    COUNT(DISTINCT c.id) as comment_count,
    (COUNT(DISTINCT pl.user_id) + COUNT(DISTINCT c.id) * 2) as engagement_score
FROM post p
JOIN "user" u ON p.owner_id = u.id
LEFT JOIN brew b ON p.brew_id = b.id
LEFT JOIN post_likes pl ON p.id = pl.post_id
LEFT JOIN comment c ON p.id = c.post_id
WHERE p.created_at > NOW() - INTERVAL '1 day' * $1
    AND p.visibility = 'public'
GROUP BY p.id, u.username, b.name
HAVING (COUNT(DISTINCT pl.user_id) + COUNT(DISTINCT c.id)) > 0
ORDER BY engagement_score DESC
LIMIT $2
`

type GetMostEngagingContentParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetMostEngagingContentRow struct {
	ID              string    `json:"id"`
	Title           string    `json:"title"`
	CreatedAt       time.Time `json:"created_at"`
	Username        string    `json:"username"`
	BrewName        *string   `json:"brew_name"`
	LikeCount       int64     `json:"like_count"`
	CommentCount    int64     `json:"comment_count"`
	EngagementScore int32     `json:"engagement_score"`
}

// 13. GET MOST ENGAGING CONTENT
// Parameters: $1 = days, $2 = limit
// Returns: Posts with highest engagement rate
// Usage: Identify viral content
func (q *Queries) GetMostEngagingContent(ctx context.Context, arg GetMostEngagingContentParams) ([]GetMostEngagingContentRow, error) {
	rows, err := q.db.Query(ctx, getMostEngagingContent, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMostEngagingContentRow{}
	for rows.Next() {
		var i GetMostEngagingContentRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.Username,
			&i.BrewName,
			&i.LikeCount,
			&i.CommentCount,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformOverviewStats = `-- name: GetPlatformOverviewStats :one

SELECT
    (SELECT COUNT(*) FROM "user") as total_users,
    (SELECT COUNT(*) FROM post) as total_posts,
    (SELECT COUNT(*) FROM brew WHERE is_public = true) as total_public_brews,
    (SELECT COUNT(*) FROM user_friendships WHERE status = 'accepted') / 2 as total_friendships,
    (SELECT COUNT(*) FROM post_likes) as total_likes,
    (SELECT COUNT(*) FROM comment) as total_comments,
    (SELECT COALESCE(AVG(rating), 0) FROM post) as avg_post_rating
`

type GetPlatformOverviewStatsRow struct {
	TotalUsers       int64       `json:"total_users"`
	TotalPosts       int64       `json:"total_posts"`
	TotalPublicBrews int64       `json:"total_public_brews"`
	TotalFriendships int32       `json:"total_friendships"`
	TotalLikes       int64       `json:"total_likes"`
	TotalComments    int64       `json:"total_comments"`
	AvgPostRating    interface{} `json:"avg_post_rating"`
}

// ----------------------------------------------------------------------------
// PLATFORM ANALYTICS
// ----------------------------------------------------------------------------
// 5. GET PLATFORM OVERVIEW STATS
// Parameters: None
// Returns: Platform-wide statistics
// Usage: Admin dashboard, homepage stats
func (q *Queries) GetPlatformOverviewStats(ctx context.Context) (GetPlatformOverviewStatsRow, error) {
	row := q.db.QueryRow(ctx, getPlatformOverviewStats)
	var i GetPlatformOverviewStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.TotalPosts,
		&i.TotalPublicBrews,
		&i.TotalFriendships,
		&i.TotalLikes,
		&i.TotalComments,
		&i.AvgPostRating,
	)
	return i, err
}

const getRatingDistribution = `-- name: GetRatingDistribution :many
SELECT
    rating,
    COUNT(*) as post_count
FROM post
WHERE rating IS NOT NULL
GROUP BY rating
ORDER BY rating DESC
`

type GetRatingDistributionRow struct {
	Rating    pgtype.Numeric `json:"rating"`
	PostCount int64          `json:"post_count"`
}

// 9. GET RATING DISTRIBUTION
// Parameters: None
// Returns: Count of posts by rating
// Usage: Rating distribution chart
func (q *Queries) GetRatingDistribution(ctx context.Context) ([]GetRatingDistributionRow, error) {
	rows, err := q.db.Query(ctx, getRatingDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingDistributionRow{}
	for rows.Next() {
		var i GetRatingDistributionRow
		if err := rows.Scan(&i.Rating, &i.PostCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopContributors = `-- name: GetTopContributors :many
SELECT
    u.id,
    u.username,
    u.profile_picture_url,
    COUNT(DISTINCT p.id) as post_count,
    COUNT(DISTINCT c.id) as comment_count,
    COUNT(DISTINCT pl.post_id) as like_count,
    (COUNT(DISTINCT p.id) * 10 + COUNT(DISTINCT c.id) * 3 + COUNT(DISTINCT pl.post_id)) as activity_score
FROM "user" u
LEFT JOIN post p ON u.id = p.owner_id AND p.created_at > NOW() - INTERVAL '1 day' * $1
LEFT JOIN comment c ON u.id = c.owner_id AND c.created_at > NOW() - INTERVAL '1 day' * $1
LEFT JOIN post_likes pl ON u.id = pl.user_id AND pl.created_at > NOW() - INTERVAL '1 day' * $1
GROUP BY u.id
HAVING COUNT(DISTINCT p.id) > 0 OR COUNT(DISTINCT c.id) > 0 OR COUNT(DISTINCT pl.post_id) > 0
ORDER BY activity_score DESC
LIMIT $2
`

type GetTopContributorsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetTopContributorsRow struct {
	ID                string  `json:"id"`
	Username          string  `json:"username"`
	ProfilePictureUrl *string `json:"profile_picture_url"`
	PostCount         int64   `json:"post_count"`
	CommentCount      int64   `json:"comment_count"`
	LikeCount         int64   `json:"like_count"`
	ActivityScore     int32   `json:"activity_score"`
}

// 10. GET TOP CONTRIBUTORS
// Parameters: $1 = days (time window), $2 = limit
// Returns: Most active users by various metrics
// Usage: "Top contributors" leaderboard
func (q *Queries) GetTopContributors(ctx context.Context, arg GetTopContributorsParams) ([]GetTopContributorsRow, error) {
	rows, err := q.db.Query(ctx, getTopContributors, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopContributorsRow{}
	for rows.Next() {
		var i GetTopContributorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ProfilePictureUrl,
			&i.PostCount,
			&i.CommentCount,
			&i.LikeCount,
			&i.ActivityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivityStats = `-- name: GetUserActivityStats :one



SELECT
    u.id,
    u.username,
    u.joined_at,
    (SELECT COUNT(*) FROM post WHERE owner_id = u.id) as total_posts,
    (SELECT COALESCE(AVG(rating), 0) FROM post WHERE owner_id = u.id) as avg_rating,
    (SELECT COUNT(DISTINCT pl.user_id)
     FROM post p
     LEFT JOIN post_likes pl ON p.id = pl.post_id
     WHERE p.owner_id = u.id) as total_likes_received,
    (SELECT COUNT(DISTINCT c.id)
     FROM post p
     LEFT JOIN comment c ON p.id = c.post_id
     WHERE p.owner_id = u.id) as total_comments_received,
    (SELECT COUNT(*) FROM user_friendships WHERE user_id = u.id AND status = 'accepted') as friend_count,
    (SELECT COUNT(*) FROM post_likes WHERE user_id = u.id) as total_likes_given,
    (SELECT COUNT(*) FROM comment WHERE owner_id = u.id) as total_comments_given
FROM "user" u
WHERE u.id = $1
`

type GetUserActivityStatsRow struct {
	ID                    string             `json:"id"`
	Username              string             `json:"username"`
	JoinedAt              pgtype.Timestamptz `json:"joined_at"`
	TotalPosts            int64              `json:"total_posts"`
	AvgRating             interface{}        `json:"avg_rating"`
	TotalLikesReceived    int64              `json:"total_likes_received"`
	TotalCommentsReceived int64              `json:"total_comments_received"`
	FriendCount           int64              `json:"friend_count"`
	TotalLikesGiven       int64              `json:"total_likes_given"`
	TotalCommentsGiven    int64              `json:"total_comments_given"`
}

// ============================================================================
// ANALYTICS QUERIES
// ============================================================================
// Operations for statistics, metrics, and insights
// ----------------------------------------------------------------------------
// USER ANALYTICS
// ----------------------------------------------------------------------------
// 1. GET USER ACTIVITY STATS
// Parameters: $1 = user_id
// Returns: Comprehensive user statistics
// Usage: User dashboard, admin analytics, insights page
// Note: Uses subqueries to prevent Cartesian product and ensure accurate counts
func (q *Queries) GetUserActivityStats(ctx context.Context, id string) (GetUserActivityStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserActivityStats, id)
	var i GetUserActivityStatsRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.JoinedAt,
		&i.TotalPosts,
		&i.AvgRating,
		&i.TotalLikesReceived,
		&i.TotalCommentsReceived,
		&i.FriendCount,
		&i.TotalLikesGiven,
		&i.TotalCommentsGiven,
	)
	return i, err
}

const getUserFavoriteBrewMethods = `-- name: GetUserFavoriteBrewMethods :many
SELECT
    b.brew_method,
    COUNT(p.id) as usage_count,
    AVG(p.rating) as avg_rating
FROM post p
JOIN brew b ON p.brew_id = b.id
WHERE p.owner_id = $1 AND b.brew_method IS NOT NULL
GROUP BY b.brew_method
ORDER BY usage_count DESC
`

type GetUserFavoriteBrewMethodsRow struct {
	BrewMethod *string `json:"brew_method"`
	UsageCount int64   `json:"usage_count"`
	AvgRating  float64 `json:"avg_rating"`
}

// 3. GET USER'S FAVORITE BREW METHODS
// Parameters: $1 = user_id
// Returns: Brew methods user posts about most
// Usage: User preferences insights
func (q *Queries) GetUserFavoriteBrewMethods(ctx context.Context, ownerID string) ([]GetUserFavoriteBrewMethodsRow, error) {
	rows, err := q.db.Query(ctx, getUserFavoriteBrewMethods, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserFavoriteBrewMethodsRow{}
	for rows.Next() {
		var i GetUserFavoriteBrewMethodsRow
		if err := rows.Scan(&i.BrewMethod, &i.UsageCount, &i.AvgRating); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPostingActivityOverTime = `-- name: GetUserPostingActivityOverTime :many
SELECT
    DATE(p.created_at) as post_date,
    COUNT(*) as post_count
FROM post p
WHERE p.owner_id = $1
    AND p.created_at > NOW() - INTERVAL '1 day' * $2
GROUP BY DATE(p.created_at)
ORDER BY post_date DESC
`

type GetUserPostingActivityOverTimeParams struct {
	OwnerID string      `json:"owner_id"`
	Column2 interface{} `json:"column_2"`
}

type GetUserPostingActivityOverTimeRow struct {
	PostDate  pgtype.Date `json:"post_date"`
	PostCount int64       `json:"post_count"`
}

// 2. GET USER POSTING ACTIVITY OVER TIME
// Parameters: $1 = user_id, $2 = days (e.g., 30)
// Returns: Posts per day in time period
// Usage: Activity graph on profile
func (q *Queries) GetUserPostingActivityOverTime(ctx context.Context, arg GetUserPostingActivityOverTimeParams) ([]GetUserPostingActivityOverTimeRow, error) {
	rows, err := q.db.Query(ctx, getUserPostingActivityOverTime, arg.OwnerID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPostingActivityOverTimeRow{}
	for rows.Next() {
		var i GetUserPostingActivityOverTimeRow
		if err := rows.Scan(&i.PostDate, &i.PostCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRetentionByCohort = `-- name: GetUserRetentionByCohort :many

SELECT
    DATE_TRUNC('month', p.created_at) as activity_month,
    COUNT(DISTINCT p.owner_id) as active_users,
    (SELECT COUNT(*) FROM "user" u2 WHERE DATE_TRUNC('month', u2.joined_at) = $1) as cohort_size,
    ROUND(
        COUNT(DISTINCT p.owner_id)::numeric /
        (SELECT COUNT(*) FROM "user" u3 WHERE DATE_TRUNC('month', u3.joined_at) = $1) * 100,
        2
    ) as retention_rate
FROM post p
JOIN "user" u ON p.owner_id = u.id
WHERE DATE_TRUNC('month', u.joined_at) = $1
GROUP BY DATE_TRUNC('month', p.created_at)
ORDER BY activity_month
`

type GetUserRetentionByCohortRow struct {
	ActivityMonth pgtype.Interval `json:"activity_month"`
	ActiveUsers   int64           `json:"active_users"`
	CohortSize    int64           `json:"cohort_size"`
	RetentionRate decimal.Decimal `json:"retention_rate"`
}

// ----------------------------------------------------------------------------
// RETENTION & COHORT ANALYSIS
// ----------------------------------------------------------------------------
// 14. GET USER RETENTION BY COHORT
// Parameters: $1 = cohort_month (e.g., '2024-01')
// Returns: Users who joined in cohort and posted in subsequent months
// Usage: Retention analysis
func (q *Queries) GetUserRetentionByCohort(ctx context.Context, joinedAt pgtype.Timestamptz) ([]GetUserRetentionByCohortRow, error) {
	rows, err := q.db.Query(ctx, getUserRetentionByCohort, joinedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserRetentionByCohortRow{}
	for rows.Next() {
		var i GetUserRetentionByCohortRow
		if err := rows.Scan(
			&i.ActivityMonth,
			&i.ActiveUsers,
			&i.CohortSize,
			&i.RetentionRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTopBrews = `-- name: GetUserTopBrews :many
SELECT
    b.id,
    b.name,
    b.brew_method,
    COUNT(p.id) as post_count,
    AVG(p.rating) as avg_rating,
    MAX(p.created_at) as last_posted
FROM brew b
JOIN post p ON b.id = p.brew_id
WHERE p.owner_id = $1
GROUP BY b.id
ORDER BY post_count DESC, avg_rating DESC
LIMIT $2
`

type GetUserTopBrewsParams struct {
	OwnerID string `json:"owner_id"`
	Limit   int32  `json:"limit"`
}

type GetUserTopBrewsRow struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	BrewMethod *string     `json:"brew_method"`
	PostCount  int64       `json:"post_count"`
	AvgRating  float64     `json:"avg_rating"`
	LastPosted interface{} `json:"last_posted"`
}

// 4. GET USER'S TOP BREWS
// Parameters: $1 = user_id, $2 = limit
// Returns: Brews user has posted about most
// Usage: "Your top brews" section
func (q *Queries) GetUserTopBrews(ctx context.Context, arg GetUserTopBrewsParams) ([]GetUserTopBrewsRow, error) {
	rows, err := q.db.Query(ctx, getUserTopBrews, arg.OwnerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTopBrewsRow{}
	for rows.Next() {
		var i GetUserTopBrewsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BrewMethod,
			&i.PostCount,
			&i.AvgRating,
			&i.LastPosted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
